!(function(t) {
  if (typeof exports === "object" && typeof module !== "undefined")
    module.exports = t();
  else if (typeof define === "function" && define.amd) define([], t);
  else {
    let e;
    (e =
      typeof window !== "undefined"
        ? window
        : typeof global !== "undefined"
        ? global
        : typeof self !== "undefined"
        ? self
        : this),
      (e.jsyaml = t());
  }
})(function() {
  let t;
  return (function e(t, n, i) {
    function r(a, s) {
      if (!n[a]) {
        if (!t[a]) {
          const c = typeof require === "function" && require;
          if (!s && c) return c(a, !0);
          if (o) return o(a, !0);
          const u = new Error(`Cannot find module '${a}'`);
          throw ((u.code = "MODULE_NOT_FOUND"), u);
        }
        const l = (n[a] = { exports: {} });
        t[a][0].call(
          l.exports,
          function(e) {
            const n = t[a][1][e];
            return r(n || e);
          },
          l,
          l.exports,
          e,
          t,
          n,
          i,
        );
      }
      return n[a].exports;
    }
    for (
      var o = typeof require === "function" && require, a = 0;
      a < i.length;
      a++
    )
      r(i[a]);
    return r;
  })(
    {
      1: [
        function(t, e, n) {
          function i(t) {
            return function() {
              throw new Error(
                `Function ${t} is deprecated and cannot be used.`,
              );
            };
          }
          const r = t("./js-yaml/loader");
          const o = t("./js-yaml/dumper");
          (e.exports.Type = t("./js-yaml/type")),
            (e.exports.Schema = t("./js-yaml/schema")),
            (e.exports.FAILSAFE_SCHEMA = t("./js-yaml/schema/failsafe")),
            (e.exports.JSON_SCHEMA = t("./js-yaml/schema/json")),
            (e.exports.CORE_SCHEMA = t("./js-yaml/schema/core")),
            (e.exports.DEFAULT_SAFE_SCHEMA = t(
              "./js-yaml/schema/default_safe",
            )),
            (e.exports.DEFAULT_FULL_SCHEMA = t(
              "./js-yaml/schema/default_full",
            )),
            (e.exports.load = r.load),
            (e.exports.loadAll = r.loadAll),
            (e.exports.safeLoad = r.safeLoad),
            (e.exports.safeLoadAll = r.safeLoadAll),
            (e.exports.dump = o.dump),
            (e.exports.safeDump = o.safeDump),
            (e.exports.YAMLException = t("./js-yaml/exception")),
            (e.exports.MINIMAL_SCHEMA = t("./js-yaml/schema/failsafe")),
            (e.exports.SAFE_SCHEMA = t("./js-yaml/schema/default_safe")),
            (e.exports.DEFAULT_SCHEMA = t("./js-yaml/schema/default_full")),
            (e.exports.scan = i("scan")),
            (e.exports.parse = i("parse")),
            (e.exports.compose = i("compose")),
            (e.exports.addConstructor = i("addConstructor"));
        },
        {
          "./js-yaml/dumper": 3,
          "./js-yaml/exception": 4,
          "./js-yaml/loader": 5,
          "./js-yaml/schema": 7,
          "./js-yaml/schema/core": 8,
          "./js-yaml/schema/default_full": 9,
          "./js-yaml/schema/default_safe": 10,
          "./js-yaml/schema/failsafe": 11,
          "./js-yaml/schema/json": 12,
          "./js-yaml/type": 13,
        },
      ],
      2: [
        function(t, e, n) {
          function i(t) {
            return typeof t === "undefined" || t === null;
          }
          function r(t) {
            return typeof t === "object" && t !== null;
          }
          function o(t) {
            return Array.isArray(t) ? t : i(t) ? [] : [t];
          }
          function a(t, e) {
            let n;
            let i;
            let r;
            let o;
            if (e)
              for (o = Object.keys(e), n = 0, i = o.length; i > n; n += 1)
                (r = o[n]), (t[r] = e[r]);
            return t;
          }
          function s(t, e) {
            let n;
            let i = "";
            for (n = 0; e > n; n += 1) i += t;
            return i;
          }
          function c(t) {
            return t === 0 && Number.NEGATIVE_INFINITY === 1 / t;
          }
          (e.exports.isNothing = i),
            (e.exports.isObject = r),
            (e.exports.toArray = o),
            (e.exports.repeat = s),
            (e.exports.isNegativeZero = c),
            (e.exports.extend = a);
        },
        {},
      ],
      3: [
        function(t, e, n) {
          function i(t, e) {
            let n;
            let i;
            let r;
            let o;
            let a;
            let s;
            let c;
            if (e === null) return {};
            for (n = {}, i = Object.keys(e), r = 0, o = i.length; o > r; r += 1)
              (a = i[r]),
                (s = String(e[a])),
                a.slice(0, 2) === "!!" &&
                  (a = `tag:yaml.org,2002:${a.slice(2)}`),
                (c = t.compiledTypeMap[a]),
                c && E.call(c.styleAliases, s) && (s = c.styleAliases[s]),
                (n[a] = s);
            return n;
          }
          function r(t) {
            let e;
            let n;
            let i;
            if (((e = t.toString(16).toUpperCase()), t <= 255))
              (n = "x"), (i = 2);
            else if (t <= 65535) (n = "u"), (i = 4);
            else {
              if (!(t <= 4294967295))
                throw new O(
                  "code point within a string may not be greater than 0xFFFFFFFF",
                );
              (n = "U"), (i = 8);
            }
            return `\\${n}${j.repeat("0", i - e.length)}${e}`;
          }
          function o(t) {
            (this.schema = t.schema || S),
              (this.indent = Math.max(1, t.indent || 2)),
              (this.skipInvalid = t.skipInvalid || !1),
              (this.flowLevel = j.isNothing(t.flowLevel) ? -1 : t.flowLevel),
              (this.styleMap = i(this.schema, t.styles || null)),
              (this.sortKeys = t.sortKeys || !1),
              (this.lineWidth = t.lineWidth || 80),
              (this.implicitTypes = this.schema.compiledImplicit),
              (this.explicitTypes = this.schema.compiledExplicit),
              (this.tag = null),
              (this.result = ""),
              (this.duplicates = []),
              (this.usedDuplicates = null);
          }
          function a(t, e) {
            for (
              var n, i = j.repeat(" ", e), r = 0, o = -1, a = "", s = t.length;
              s > r;

            )
              (o = t.indexOf("\n", r)),
                o === -1
                  ? ((n = t.slice(r)), (r = s))
                  : ((n = t.slice(r, o + 1)), (r = o + 1)),
                n.length && n !== "\n" && (a += i),
                (a += n);
            return a;
          }
          function s(t, e) {
            return `\n${j.repeat(" ", t.indent * e)}`;
          }
          function c(t, e) {
            let n;
            let i;
            let r;
            for (n = 0, i = t.implicitTypes.length; i > n; n += 1)
              if (((r = t.implicitTypes[n]), r.resolve(e))) return !0;
            return !1;
          }
          function u(t) {
            (this.source = t), (this.result = ""), (this.checkpoint = 0);
          }
          function l(t, e, n, i) {
            let r;
            let o;
            let s;
            let l;
            let f;
            let m;
            let y;
            let g;
            let v;
            let x;
            let A;
            let b;
            let w;
            let k;
            let C;
            let j;
            let O;
            let S;
            let _;
            let I;
            let E;
            if (e.length === 0) return void (t.dump = "''");
            if (et.indexOf(e) !== -1) return void (t.dump = `'${e}'`);
            for (
              r = !0,
                o = e.length ? e.charCodeAt(0) : 0,
                s = M === o || M === e.charCodeAt(e.length - 1),
                (K === o || W === o || G === o || z === o) && (r = !1),
                s ? ((r = !1), (l = !1), (f = !1)) : ((l = !i), (f = !i)),
                m = !0,
                y = new u(e),
                g = !1,
                v = 0,
                x = 0,
                A = t.indent * n,
                b = t.lineWidth,
                b === -1 && (b = 9007199254740991),
                A < 40 ? (b -= A) : (b = 40),
                k = 0;
              k < e.length;
              k++
            ) {
              if (((w = e.charCodeAt(k)), r)) {
                if (h(w)) continue;
                r = !1;
              }
              m && w === P && (m = !1),
                (C = tt[w]),
                (j = d(w)),
                (C || j) &&
                  (w !== N && w !== D && w !== P
                    ? ((l = !1), (f = !1))
                    : w === N &&
                      ((g = !0),
                      (m = !1),
                      k > 0 &&
                        ((O = e.charCodeAt(k - 1)),
                        O === M && ((f = !1), (l = !1))),
                      l && ((S = k - v), (v = k), S > x && (x = S))),
                  w !== D && (m = !1),
                  y.takeUpTo(k),
                  y.escapeChar());
            }
            if (
              (r && c(t, e) && (r = !1),
              (_ = ""),
              (l || f) &&
                ((I = 0),
                e.charCodeAt(e.length - 1) === N &&
                  ((I += 1), e.charCodeAt(e.length - 2) === N && (I += 1)),
                I === 0 ? (_ = "-") : I === 2 && (_ = "+")),
              f && b > x && (l = !1),
              g || (f = !1),
              r)
            )
              t.dump = e;
            else if (m) t.dump = `'${e}'`;
            else if (l) (E = p(e, b)), (t.dump = `>${_}\n${a(E, A)}`);
            else if (f)
              _ || (e = e.replace(/\n$/, "")), (t.dump = `|${_}\n${a(e, A)}`);
            else {
              if (!y) throw new Error("Failed to dump scalar value");
              y.finish(), (t.dump = `"${y.result}"`);
            }
          }
          function p(t, e) {
            let n;
            let i = "";
            let r = 0;
            let o = t.length;
            const a = /\n+$/.exec(t);
            for (a && (o = a.index + 1); o > r; )
              (n = t.indexOf("\n", r)),
                n > o || n === -1
                  ? (i && (i += "\n\n"), (i += f(t.slice(r, o), e)), (r = o))
                  : (i && (i += "\n\n"),
                    (i += f(t.slice(r, n), e)),
                    (r = n + 1));
            return a && a[0] !== "\n" && (i += a[0]), i;
          }
          function f(t, e) {
            if (t === "") return t;
            for (
              var n,
                i,
                r,
                o = /[^\s] [^\s]/g,
                a = "",
                s = 0,
                c = 0,
                u = o.exec(t);
              u;

            )
              (n = u.index),
                n - c > e &&
                  ((i = s !== c ? s : n),
                  a && (a += "\n"),
                  (r = t.slice(c, i)),
                  (a += r),
                  (c = i + 1)),
                (s = n + 1),
                (u = o.exec(t));
            return (
              a && (a += "\n"),
              (a +=
                c !== s && t.length - c > e
                  ? `${t.slice(c, s)}\n${t.slice(s + 1)}`
                  : t.slice(c))
            );
          }
          function h(t) {
            return (
              F !== t &&
              N !== t &&
              T !== t &&
              $ !== t &&
              V !== t &&
              Z !== t &&
              J !== t &&
              X !== t &&
              U !== t &&
              Y !== t &&
              B !== t &&
              L !== t &&
              Q !== t &&
              R !== t &&
              P !== t &&
              D !== t &&
              q !== t &&
              H !== t &&
              !tt[t] &&
              !d(t)
            );
          }
          function d(t) {
            return !(
              (t >= 32 && t <= 126) ||
              t === 133 ||
              (t >= 160 && t <= 55295) ||
              (t >= 57344 && t <= 65533) ||
              (t >= 65536 && t <= 1114111)
            );
          }
          function m(t, e, n) {
            let i;
            let r;
            let o = "";
            const a = t.tag;
            for (i = 0, r = n.length; r > i; i += 1)
              A(t, e, n[i], !1, !1) && (i !== 0 && (o += ", "), (o += t.dump));
            (t.tag = a), (t.dump = `[${o}]`);
          }
          function y(t, e, n, i) {
            let r;
            let o;
            let a = "";
            const c = t.tag;
            for (r = 0, o = n.length; o > r; r += 1)
              A(t, e + 1, n[r], !0, !0) &&
                ((i && r === 0) || (a += s(t, e)), (a += `- ${t.dump}`));
            (t.tag = c), (t.dump = a || "[]");
          }
          function g(t, e, n) {
            let i;
            let r;
            let o;
            let a;
            let s;
            let c = "";
            const u = t.tag;
            const l = Object.keys(n);
            for (i = 0, r = l.length; r > i; i += 1)
              (s = ""),
                i !== 0 && (s += ", "),
                (o = l[i]),
                (a = n[o]),
                A(t, e, o, !1, !1) &&
                  (t.dump.length > 1024 && (s += "? "),
                  (s += `${t.dump}: `),
                  A(t, e, a, !1, !1) && ((s += t.dump), (c += s)));
            (t.tag = u), (t.dump = `{${c}}`);
          }
          function v(t, e, n, i) {
            let r;
            let o;
            let a;
            let c;
            let u;
            let l;
            let p = "";
            const f = t.tag;
            const h = Object.keys(n);
            if (t.sortKeys === !0) h.sort();
            else if (typeof t.sortKeys === "function") h.sort(t.sortKeys);
            else if (t.sortKeys)
              throw new O("sortKeys must be a boolean or a function");
            for (r = 0, o = h.length; o > r; r += 1)
              (l = ""),
                (i && r === 0) || (l += s(t, e)),
                (a = h[r]),
                (c = n[a]),
                A(t, e + 1, a, !0, !0, !0) &&
                  ((u =
                    (t.tag !== null && t.tag !== "?") ||
                    (t.dump && t.dump.length > 1024)),
                  u && (l += t.dump && N === t.dump.charCodeAt(0) ? "?" : "? "),
                  (l += t.dump),
                  u && (l += s(t, e)),
                  A(t, e + 1, c, !0, u) &&
                    ((l += t.dump && N === t.dump.charCodeAt(0) ? ":" : ": "),
                    (l += t.dump),
                    (p += l)));
            (t.tag = f), (t.dump = p || "{}");
          }
          function x(t, e, n) {
            let i;
            let r;
            let o;
            let a;
            let s;
            let c;
            for (
              r = n ? t.explicitTypes : t.implicitTypes, o = 0, a = r.length;
              a > o;
              o += 1
            )
              if (
                ((s = r[o]),
                (s.instanceOf || s.predicate) &&
                  (!s.instanceOf ||
                    (typeof e === "object" && e instanceof s.instanceOf)) &&
                  (!s.predicate || s.predicate(e)))
              ) {
                if (((t.tag = n ? s.tag : "?"), s.represent)) {
                  if (
                    ((c = t.styleMap[s.tag] || s.defaultStyle),
                    I.call(s.represent) === "[object Function]")
                  )
                    i = s.represent(e, c);
                  else {
                    if (!E.call(s.represent, c))
                      throw new O(
                        `!<${s.tag}> tag resolver accepts not "${c}" style`,
                      );
                    i = s.represent[c](e, c);
                  }
                  t.dump = i;
                }
                return !0;
              }
            return !1;
          }
          function A(t, e, n, i, r, o) {
            (t.tag = null), (t.dump = n), x(t, n, !1) || x(t, n, !0);
            const a = I.call(t.dump);
            i && (i = t.flowLevel < 0 || t.flowLevel > e);
            let s;
            let c;
            const u = a === "[object Object]" || a === "[object Array]";
            if (
              (u && ((s = t.duplicates.indexOf(n)), (c = s !== -1)),
              ((t.tag !== null && t.tag !== "?") ||
                c ||
                (t.indent !== 2 && e > 0)) &&
                (r = !1),
              c && t.usedDuplicates[s])
            )
              t.dump = `*ref_${s}`;
            else {
              if (
                (u && c && !t.usedDuplicates[s] && (t.usedDuplicates[s] = !0),
                a === "[object Object]")
              )
                i && Object.keys(t.dump).length !== 0
                  ? (v(t, e, t.dump, r), c && (t.dump = `&ref_${s}${t.dump}`))
                  : (g(t, e, t.dump), c && (t.dump = `&ref_${s} ${t.dump}`));
              else if (a === "[object Array]")
                i && t.dump.length !== 0
                  ? (y(t, e, t.dump, r), c && (t.dump = `&ref_${s}${t.dump}`))
                  : (m(t, e, t.dump), c && (t.dump = `&ref_${s} ${t.dump}`));
              else {
                if (a !== "[object String]") {
                  if (t.skipInvalid) return !1;
                  throw new O(`unacceptable kind of an object to dump ${a}`);
                }
                t.tag !== "?" && l(t, t.dump, e, o);
              }
              t.tag !== null &&
                t.tag !== "?" &&
                (t.dump = `!<${t.tag}> ${t.dump}`);
            }
            return !0;
          }
          function b(t, e) {
            let n;
            let i;
            const r = [];
            const o = [];
            for (w(t, r, o), n = 0, i = o.length; i > n; n += 1)
              e.duplicates.push(r[o[n]]);
            e.usedDuplicates = new Array(i);
          }
          function w(t, e, n) {
            let i;
            let r;
            let o;
            if (t !== null && typeof t === "object")
              if (((r = e.indexOf(t)), r !== -1))
                n.indexOf(r) === -1 && n.push(r);
              else if ((e.push(t), Array.isArray(t)))
                for (r = 0, o = t.length; o > r; r += 1) w(t[r], e, n);
              else
                for (i = Object.keys(t), r = 0, o = i.length; o > r; r += 1)
                  w(t[i[r]], e, n);
          }
          function k(t, e) {
            e = e || {};
            const n = new o(e);
            return b(t, n), A(n, 0, t, !0, !0) ? `${n.dump}\n` : "";
          }
          function C(t, e) {
            return k(t, j.extend({ schema: _ }, e));
          }
          var j = t("./common");
          var O = t("./exception");
          var S = t("./schema/default_full");
          var _ = t("./schema/default_safe");
          var I = Object.prototype.toString;
          var E = Object.prototype.hasOwnProperty;
          var F = 9;
          var N = 10;
          var T = 13;
          var M = 32;
          var L = 33;
          var D = 34;
          var U = 35;
          var q = 37;
          var Y = 38;
          var P = 39;
          var B = 42;
          var $ = 44;
          var K = 45;
          var H = 58;
          var R = 62;
          var W = 63;
          var G = 64;
          var V = 91;
          var Z = 93;
          var z = 96;
          var J = 123;
          var Q = 124;
          var X = 125;
          var tt = {};
          (tt[0] = "\\0"),
            (tt[7] = "\\a"),
            (tt[8] = "\\b"),
            (tt[9] = "\\t"),
            (tt[10] = "\\n"),
            (tt[11] = "\\v"),
            (tt[12] = "\\f"),
            (tt[13] = "\\r"),
            (tt[27] = "\\e"),
            (tt[34] = '\\"'),
            (tt[92] = "\\\\"),
            (tt[133] = "\\N"),
            (tt[160] = "\\_"),
            (tt[8232] = "\\L"),
            (tt[8233] = "\\P");
          var et = [
            "y",
            "Y",
            "yes",
            "Yes",
            "YES",
            "on",
            "On",
            "ON",
            "n",
            "N",
            "no",
            "No",
            "NO",
            "off",
            "Off",
            "OFF",
          ];
          (u.prototype.takeUpTo = function(t) {
            let e;
            if (t < this.checkpoint)
              throw ((e = new Error("position should be > checkpoint")),
              (e.position = t),
              (e.checkpoint = this.checkpoint),
              e);
            return (
              (this.result += this.source.slice(this.checkpoint, t)),
              (this.checkpoint = t),
              this
            );
          }),
            (u.prototype.escapeChar = function() {
              let t;
              let e;
              return (
                (t = this.source.charCodeAt(this.checkpoint)),
                (e = tt[t] || r(t)),
                (this.result += e),
                (this.checkpoint += 1),
                this
              );
            }),
            (u.prototype.finish = function() {
              this.source.length > this.checkpoint &&
                this.takeUpTo(this.source.length);
            }),
            (e.exports.dump = k),
            (e.exports.safeDump = C);
        },
        {
          "./common": 2,
          "./exception": 4,
          "./schema/default_full": 9,
          "./schema/default_safe": 10,
        },
      ],
      4: [
        function(t, e, n) {
          function i(t, e) {
            Error.call(this),
              Error.captureStackTrace
                ? Error.captureStackTrace(this, this.constructor)
                : (this.stack = new Error().stack || ""),
              (this.name = "YAMLException"),
              (this.reason = t),
              (this.mark = e),
              (this.message =
                (this.reason || "(unknown reason)") +
                (this.mark ? ` ${this.mark.toString()}` : ""));
          }
          const r = t("inherit");
          r(i, Error),
            (i.prototype.toString = function(t) {
              let e = `${this.name}: `;
              return (
                (e += this.reason || "(unknown reason)"),
                !t && this.mark && (e += ` ${this.mark.toString()}`),
                e
              );
            }),
            (e.exports = i);
        },
        { inherit: 31 },
      ],
      5: [
        function(t, e, n) {
          function i(t) {
            return t === 10 || t === 13;
          }
          function r(t) {
            return t === 9 || t === 32;
          }
          function o(t) {
            return t === 9 || t === 32 || t === 10 || t === 13;
          }
          function a(t) {
            return t === 44 || t === 91 || t === 93 || t === 123 || t === 125;
          }
          function s(t) {
            let e;
            return t >= 48 && t <= 57
              ? t - 48
              : ((e = 32 | t), e >= 97 && e <= 102 ? e - 97 + 10 : -1);
          }
          function c(t) {
            return t === 120 ? 2 : t === 117 ? 4 : t === 85 ? 8 : 0;
          }
          function u(t) {
            return t >= 48 && t <= 57 ? t - 48 : -1;
          }
          function l(t) {
            return t === 48
              ? "\0"
              : t === 97
              ? ""
              : t === 98
              ? "\b"
              : t === 116
              ? "\t"
              : t === 9
              ? "\t"
              : t === 110
              ? "\n"
              : t === 118
              ? "\x0B"
              : t === 102
              ? "\f"
              : t === 114
              ? "\r"
              : t === 101
              ? ""
              : t === 32
              ? " "
              : t === 34
              ? '"'
              : t === 47
              ? "/"
              : t === 92
              ? "\\"
              : t === 78
              ? "Â…"
              : t === 95
              ? "Â "
              : t === 76
              ? "\u2028"
              : t === 80
              ? "\u2029"
              : "";
          }
          function p(t) {
            return t <= 65535
              ? String.fromCharCode(t)
              : String.fromCharCode(
                  ((t - 65536) >> 10) + 55296,
                  ((t - 65536) & 1023) + 56320,
                );
          }
          function f(t, e) {
            (this.input = t),
              (this.filename = e.filename || null),
              (this.schema = e.schema || H),
              (this.onWarning = e.onWarning || null),
              (this.legacy = e.legacy || !1),
              (this.implicitTypes = this.schema.compiledImplicit),
              (this.typeMap = this.schema.compiledTypeMap),
              (this.length = t.length),
              (this.position = 0),
              (this.line = 0),
              (this.lineStart = 0),
              (this.lineIndent = 0),
              (this.documents = []);
          }
          function h(t, e) {
            return new B(
              e,
              new $(
                t.filename,
                t.input,
                t.position,
                t.line,
                t.position - t.lineStart,
              ),
            );
          }
          function d(t, e) {
            throw h(t, e);
          }
          function m(t, e) {
            t.onWarning && t.onWarning.call(null, h(t, e));
          }
          function y(t, e, n, i) {
            let r;
            let o;
            let a;
            let s;
            if (n > e) {
              if (((s = t.input.slice(e, n)), i))
                for (r = 0, o = s.length; o > r; r += 1)
                  (a = s.charCodeAt(r)),
                    a === 9 ||
                      (a >= 32 && a <= 1114111) ||
                      d(t, "expected valid JSON character");
              else
                X.test(s) &&
                  d(t, "the stream contains non-printable characters");
              t.result += s;
            }
          }
          function g(t, e, n) {
            let i;
            let r;
            let o;
            let a;
            for (
              P.isObject(n) ||
                d(
                  t,
                  "cannot merge mappings; the provided source object is unacceptable",
                ),
                i = Object.keys(n),
                o = 0,
                a = i.length;
              a > o;
              o += 1
            )
              (r = i[o]), R.call(e, r) || (e[r] = n[r]);
          }
          function v(t, e, n, i, r) {
            let o;
            let a;
            if (
              ((i = String(i)),
              e === null && (e = {}),
              n === "tag:yaml.org,2002:merge")
            )
              if (Array.isArray(r))
                for (o = 0, a = r.length; a > o; o += 1) g(t, e, r[o]);
              else g(t, e, r);
            else e[i] = r;
            return e;
          }
          function x(t) {
            let e;
            (e = t.input.charCodeAt(t.position)),
              e === 10
                ? t.position++
                : e === 13
                ? (t.position++,
                  t.input.charCodeAt(t.position) === 10 && t.position++)
                : d(t, "a line break is expected"),
              (t.line += 1),
              (t.lineStart = t.position);
          }
          function A(t, e, n) {
            for (var o = 0, a = t.input.charCodeAt(t.position); a !== 0; ) {
              for (; r(a); ) a = t.input.charCodeAt(++t.position);
              if (e && a === 35)
                do a = t.input.charCodeAt(++t.position);
                while (a !== 10 && a !== 13 && a !== 0);
              if (!i(a)) break;
              for (
                x(t), a = t.input.charCodeAt(t.position), o++, t.lineIndent = 0;
                a === 32;

              )
                t.lineIndent++, (a = t.input.charCodeAt(++t.position));
            }
            return (
              n !== -1 &&
                o !== 0 &&
                t.lineIndent < n &&
                m(t, "deficient indentation"),
              o
            );
          }
          function b(t) {
            let e;
            let n = t.position;
            return (
              (e = t.input.charCodeAt(n)),
              !(
                (e !== 45 && e !== 46) ||
                t.input.charCodeAt(n + 1) !== e ||
                t.input.charCodeAt(n + 2) !== e ||
                ((n += 3), (e = t.input.charCodeAt(n)), e !== 0 && !o(e))
              )
            );
          }
          function w(t, e) {
            e === 1
              ? (t.result += " ")
              : e > 1 && (t.result += P.repeat("\n", e - 1));
          }
          function k(t, e, n) {
            let s;
            let c;
            let u;
            let l;
            let p;
            let f;
            let h;
            let d;
            let m;
            const g = t.kind;
            const v = t.result;
            if (
              ((m = t.input.charCodeAt(t.position)),
              o(m) ||
                a(m) ||
                m === 35 ||
                m === 38 ||
                m === 42 ||
                m === 33 ||
                m === 124 ||
                m === 62 ||
                m === 39 ||
                m === 34 ||
                m === 37 ||
                m === 64 ||
                m === 96)
            )
              return !1;
            if (
              (m === 63 || m === 45) &&
              ((c = t.input.charCodeAt(t.position + 1)), o(c) || (n && a(c)))
            )
              return !1;
            for (
              t.kind = "scalar", t.result = "", u = l = t.position, p = !1;
              m !== 0;

            ) {
              if (m === 58) {
                if (
                  ((c = t.input.charCodeAt(t.position + 1)),
                  o(c) || (n && a(c)))
                )
                  break;
              } else if (m === 35) {
                if (((s = t.input.charCodeAt(t.position - 1)), o(s))) break;
              } else {
                if ((t.position === t.lineStart && b(t)) || (n && a(m))) break;
                if (i(m)) {
                  if (
                    ((f = t.line),
                    (h = t.lineStart),
                    (d = t.lineIndent),
                    A(t, !1, -1),
                    t.lineIndent >= e)
                  ) {
                    (p = !0), (m = t.input.charCodeAt(t.position));
                    continue;
                  }
                  (t.position = l),
                    (t.line = f),
                    (t.lineStart = h),
                    (t.lineIndent = d);
                  break;
                }
              }
              p &&
                (y(t, u, l, !1),
                w(t, t.line - f),
                (u = l = t.position),
                (p = !1)),
                r(m) || (l = t.position + 1),
                (m = t.input.charCodeAt(++t.position));
            }
            return (
              y(t, u, l, !1), !!t.result || ((t.kind = g), (t.result = v), !1)
            );
          }
          function C(t, e) {
            let n;
            let r;
            let o;
            if (((n = t.input.charCodeAt(t.position)), n !== 39)) return !1;
            for (
              t.kind = "scalar",
                t.result = "",
                t.position++,
                r = o = t.position;
              (n = t.input.charCodeAt(t.position)) !== 0;

            )
              if (n === 39) {
                if (
                  (y(t, r, t.position, !0),
                  (n = t.input.charCodeAt(++t.position)),
                  n !== 39)
                )
                  return !0;
                (r = o = t.position), t.position++;
              } else
                i(n)
                  ? (y(t, r, o, !0), w(t, A(t, !1, e)), (r = o = t.position))
                  : t.position === t.lineStart && b(t)
                  ? d(
                      t,
                      "unexpected end of the document within a single quoted scalar",
                    )
                  : (t.position++, (o = t.position));
            d(t, "unexpected end of the stream within a single quoted scalar");
          }
          function j(t, e) {
            let n;
            let r;
            let o;
            let a;
            let u;
            let l;
            if (((l = t.input.charCodeAt(t.position)), l !== 34)) return !1;
            for (
              t.kind = "scalar",
                t.result = "",
                t.position++,
                n = r = t.position;
              (l = t.input.charCodeAt(t.position)) !== 0;

            ) {
              if (l === 34) return y(t, n, t.position, !0), t.position++, !0;
              if (l === 92) {
                if (
                  (y(t, n, t.position, !0),
                  (l = t.input.charCodeAt(++t.position)),
                  i(l))
                )
                  A(t, !1, e);
                else if (l < 256 && rt[l]) (t.result += ot[l]), t.position++;
                else if ((u = c(l)) > 0) {
                  for (o = u, a = 0; o > 0; o--)
                    (l = t.input.charCodeAt(++t.position)),
                      (u = s(l)) >= 0
                        ? (a = (a << 4) + u)
                        : d(t, "expected hexadecimal character");
                  (t.result += p(a)), t.position++;
                } else d(t, "unknown escape sequence");
                n = r = t.position;
              } else
                i(l)
                  ? (y(t, n, r, !0), w(t, A(t, !1, e)), (n = r = t.position))
                  : t.position === t.lineStart && b(t)
                  ? d(
                      t,
                      "unexpected end of the document within a double quoted scalar",
                    )
                  : (t.position++, (r = t.position));
            }
            d(t, "unexpected end of the stream within a double quoted scalar");
          }
          function O(t, e) {
            let n;
            let i;
            let r;
            let a;
            let s;
            let c;
            let u;
            let l;
            let p;
            let f;
            let h;
            let m = !0;
            const y = t.tag;
            const g = t.anchor;
            if (((h = t.input.charCodeAt(t.position)), h === 91))
              (a = 93), (u = !1), (i = []);
            else {
              if (h !== 123) return !1;
              (a = 125), (u = !0), (i = {});
            }
            for (
              t.anchor !== null && (t.anchorMap[t.anchor] = i),
                h = t.input.charCodeAt(++t.position);
              h !== 0;

            ) {
              if ((A(t, !0, e), (h = t.input.charCodeAt(t.position)), h === a))
                return (
                  t.position++,
                  (t.tag = y),
                  (t.anchor = g),
                  (t.kind = u ? "mapping" : "sequence"),
                  (t.result = i),
                  !0
                );
              m || d(t, "missed comma between flow collection entries"),
                (p = l = f = null),
                (s = c = !1),
                h === 63 &&
                  ((r = t.input.charCodeAt(t.position + 1)),
                  o(r) && ((s = c = !0), t.position++, A(t, !0, e))),
                (n = t.line),
                T(t, e, W, !1, !0),
                (p = t.tag),
                (l = t.result),
                A(t, !0, e),
                (h = t.input.charCodeAt(t.position)),
                (!c && t.line !== n) ||
                  h !== 58 ||
                  ((s = !0),
                  (h = t.input.charCodeAt(++t.position)),
                  A(t, !0, e),
                  T(t, e, W, !1, !0),
                  (f = t.result)),
                u ? v(t, i, p, l, f) : i.push(s ? v(t, null, p, l, f) : l),
                A(t, !0, e),
                (h = t.input.charCodeAt(t.position)),
                h === 44
                  ? ((m = !0), (h = t.input.charCodeAt(++t.position)))
                  : (m = !1);
            }
            d(t, "unexpected end of the stream within a flow collection");
          }
          function S(t, e) {
            let n;
            let o;
            let a;
            let s;
            let c = z;
            let l = !1;
            let p = e;
            let f = 0;
            let h = !1;
            if (((s = t.input.charCodeAt(t.position)), s === 124)) o = !1;
            else {
              if (s !== 62) return !1;
              o = !0;
            }
            for (t.kind = "scalar", t.result = ""; s !== 0; )
              if (
                ((s = t.input.charCodeAt(++t.position)), s === 43 || s === 45)
              )
                z === c
                  ? (c = s === 43 ? Q : J)
                  : d(t, "repeat of a chomping mode identifier");
              else {
                if (!((a = u(s)) >= 0)) break;
                a === 0
                  ? d(
                      t,
                      "bad explicit indentation width of a block scalar; it cannot be less than one",
                    )
                  : l
                  ? d(t, "repeat of an indentation width identifier")
                  : ((p = e + a - 1), (l = !0));
              }
            if (r(s)) {
              do s = t.input.charCodeAt(++t.position);
              while (r(s));
              if (s === 35)
                do s = t.input.charCodeAt(++t.position);
                while (!i(s) && s !== 0);
            }
            for (; s !== 0; ) {
              for (
                x(t), t.lineIndent = 0, s = t.input.charCodeAt(t.position);
                (!l || t.lineIndent < p) && s === 32;

              )
                t.lineIndent++, (s = t.input.charCodeAt(++t.position));
              if ((!l && t.lineIndent > p && (p = t.lineIndent), i(s))) f++;
              else {
                if (t.lineIndent < p) {
                  c === Q
                    ? (t.result += P.repeat("\n", f))
                    : c === z && l && (t.result += "\n");
                  break;
                }
                for (
                  o
                    ? r(s)
                      ? ((h = !0), (t.result += P.repeat("\n", f + 1)))
                      : h
                      ? ((h = !1), (t.result += P.repeat("\n", f + 1)))
                      : f === 0
                      ? l && (t.result += " ")
                      : (t.result += P.repeat("\n", f))
                    : l
                    ? (t.result += P.repeat("\n", f + 1))
                    : (t.result += P.repeat("\n", f)),
                    l = !0,
                    f = 0,
                    n = t.position;
                  !i(s) && s !== 0;

                )
                  s = t.input.charCodeAt(++t.position);
                y(t, n, t.position, !1);
              }
            }
            return !0;
          }
          function _(t, e) {
            let n;
            let i;
            let r;
            const a = t.tag;
            const s = t.anchor;
            const c = [];
            let u = !1;
            for (
              t.anchor !== null && (t.anchorMap[t.anchor] = c),
                r = t.input.charCodeAt(t.position);
              r !== 0 &&
              r === 45 &&
              ((i = t.input.charCodeAt(t.position + 1)), o(i));

            )
              if (((u = !0), t.position++, A(t, !0, -1) && t.lineIndent <= e))
                c.push(null), (r = t.input.charCodeAt(t.position));
              else if (
                ((n = t.line),
                T(t, e, V, !1, !0),
                c.push(t.result),
                A(t, !0, -1),
                (r = t.input.charCodeAt(t.position)),
                (t.line === n || t.lineIndent > e) && r !== 0)
              )
                d(t, "bad indentation of a sequence entry");
              else if (t.lineIndent < e) break;
            return (
              !!u &&
              ((t.tag = a),
              (t.anchor = s),
              (t.kind = "sequence"),
              (t.result = c),
              !0)
            );
          }
          function I(t, e, n) {
            let i;
            let a;
            let s;
            let c;
            const u = t.tag;
            const l = t.anchor;
            const p = {};
            let f = null;
            let h = null;
            let m = null;
            let y = !1;
            let g = !1;
            for (
              t.anchor !== null && (t.anchorMap[t.anchor] = p),
                c = t.input.charCodeAt(t.position);
              c !== 0;

            ) {
              if (
                ((i = t.input.charCodeAt(t.position + 1)),
                (s = t.line),
                (c !== 63 && c !== 58) || !o(i))
              ) {
                if (!T(t, n, G, !1, !0)) break;
                if (t.line === s) {
                  for (c = t.input.charCodeAt(t.position); r(c); )
                    c = t.input.charCodeAt(++t.position);
                  if (c === 58)
                    (c = t.input.charCodeAt(++t.position)),
                      o(c) ||
                        d(
                          t,
                          "a whitespace character is expected after the key-value separator within a block mapping",
                        ),
                      y && (v(t, p, f, h, null), (f = h = m = null)),
                      (g = !0),
                      (y = !1),
                      (a = !1),
                      (f = t.tag),
                      (h = t.result);
                  else {
                    if (!g) return (t.tag = u), (t.anchor = l), !0;
                    d(
                      t,
                      "can not read an implicit mapping pair; a colon is missed",
                    );
                  }
                } else {
                  if (!g) return (t.tag = u), (t.anchor = l), !0;
                  d(
                    t,
                    "can not read a block mapping entry; a multiline key may not be an implicit key",
                  );
                }
              } else
                c === 63
                  ? (y && (v(t, p, f, h, null), (f = h = m = null)),
                    (g = !0),
                    (y = !0),
                    (a = !0))
                  : y
                  ? ((y = !1), (a = !0))
                  : d(
                      t,
                      "incomplete explicit mapping pair; a key node is missed",
                    ),
                  (t.position += 1),
                  (c = i);
              if (
                ((t.line === s || t.lineIndent > e) &&
                  (T(t, e, Z, !0, a) && (y ? (h = t.result) : (m = t.result)),
                  y || (v(t, p, f, h, m), (f = h = m = null)),
                  A(t, !0, -1),
                  (c = t.input.charCodeAt(t.position))),
                t.lineIndent > e && c !== 0)
              )
                d(t, "bad indentation of a mapping entry");
              else if (t.lineIndent < e) break;
            }
            return (
              y && v(t, p, f, h, null),
              g &&
                ((t.tag = u),
                (t.anchor = l),
                (t.kind = "mapping"),
                (t.result = p)),
              g
            );
          }
          function E(t) {
            let e;
            let n;
            let i;
            let r;
            let a = !1;
            let s = !1;
            if (((r = t.input.charCodeAt(t.position)), r !== 33)) return !1;
            if (
              (t.tag !== null && d(t, "duplication of a tag property"),
              (r = t.input.charCodeAt(++t.position)),
              r === 60
                ? ((a = !0), (r = t.input.charCodeAt(++t.position)))
                : r === 33
                ? ((s = !0), (n = "!!"), (r = t.input.charCodeAt(++t.position)))
                : (n = "!"),
              (e = t.position),
              a)
            ) {
              do r = t.input.charCodeAt(++t.position);
              while (r !== 0 && r !== 62);
              t.position < t.length
                ? ((i = t.input.slice(e, t.position)),
                  (r = t.input.charCodeAt(++t.position)))
                : d(t, "unexpected end of the stream within a verbatim tag");
            } else {
              for (; r !== 0 && !o(r); )
                r === 33 &&
                  (s
                    ? d(t, "tag suffix cannot contain exclamation marks")
                    : ((n = t.input.slice(e - 1, t.position + 1)),
                      nt.test(n) ||
                        d(t, "named tag handle cannot contain such characters"),
                      (s = !0),
                      (e = t.position + 1))),
                  (r = t.input.charCodeAt(++t.position));
              (i = t.input.slice(e, t.position)),
                et.test(i) &&
                  d(t, "tag suffix cannot contain flow indicator characters");
            }
            return (
              i &&
                !it.test(i) &&
                d(t, `tag name cannot contain such characters: ${i}`),
              a
                ? (t.tag = i)
                : R.call(t.tagMap, n)
                ? (t.tag = t.tagMap[n] + i)
                : n === "!"
                ? (t.tag = `!${i}`)
                : n === "!!"
                ? (t.tag = `tag:yaml.org,2002:${i}`)
                : d(t, `undeclared tag handle "${n}"`),
              !0
            );
          }
          function F(t) {
            let e;
            let n;
            if (((n = t.input.charCodeAt(t.position)), n !== 38)) return !1;
            for (
              t.anchor !== null && d(t, "duplication of an anchor property"),
                n = t.input.charCodeAt(++t.position),
                e = t.position;
              n !== 0 && !o(n) && !a(n);

            )
              n = t.input.charCodeAt(++t.position);
            return (
              t.position === e &&
                d(
                  t,
                  "name of an anchor node must contain at least one character",
                ),
              (t.anchor = t.input.slice(e, t.position)),
              !0
            );
          }
          function N(t) {
            let e;
            let n;
            let i;
            if (((i = t.input.charCodeAt(t.position)), i !== 42)) return !1;
            for (
              i = t.input.charCodeAt(++t.position), e = t.position;
              i !== 0 && !o(i) && !a(i);

            )
              i = t.input.charCodeAt(++t.position);
            return (
              t.position === e &&
                d(
                  t,
                  "name of an alias node must contain at least one character",
                ),
              (n = t.input.slice(e, t.position)),
              t.anchorMap.hasOwnProperty(n) ||
                d(t, `unidentified alias "${n}"`),
              (t.result = t.anchorMap[n]),
              A(t, !0, -1),
              !0
            );
          }
          function T(t, e, n, i, r) {
            let o;
            let a;
            let s;
            let c;
            let u;
            let l;
            let p;
            let f;
            let h = 1;
            let m = !1;
            let y = !1;
            if (
              ((t.tag = null),
              (t.anchor = null),
              (t.kind = null),
              (t.result = null),
              (o = a = s = Z === n || V === n),
              i &&
                A(t, !0, -1) &&
                ((m = !0),
                t.lineIndent > e
                  ? (h = 1)
                  : t.lineIndent === e
                  ? (h = 0)
                  : t.lineIndent < e && (h = -1)),
              h === 1)
            )
              for (; E(t) || F(t); )
                A(t, !0, -1)
                  ? ((m = !0),
                    (s = o),
                    t.lineIndent > e
                      ? (h = 1)
                      : t.lineIndent === e
                      ? (h = 0)
                      : t.lineIndent < e && (h = -1))
                  : (s = !1);
            if (
              (s && (s = m || r),
              (h === 1 || Z === n) &&
                ((p = W === n || G === n ? e : e + 1),
                (f = t.position - t.lineStart),
                h === 1
                  ? (s && (_(t, f) || I(t, f, p))) || O(t, p)
                    ? (y = !0)
                    : ((a && S(t, p)) || C(t, p) || j(t, p)
                        ? (y = !0)
                        : N(t)
                        ? ((y = !0),
                          (t.tag !== null || t.anchor !== null) &&
                            d(t, "alias node should not have any properties"))
                        : k(t, p, W === n) &&
                          ((y = !0), t.tag === null && (t.tag = "?")),
                      t.anchor !== null && (t.anchorMap[t.anchor] = t.result))
                  : h === 0 && (y = s && _(t, f))),
              t.tag !== null && t.tag !== "!")
            )
              if (t.tag === "?") {
                for (c = 0, u = t.implicitTypes.length; u > c; c += 1)
                  if (((l = t.implicitTypes[c]), l.resolve(t.result))) {
                    (t.result = l.construct(t.result)),
                      (t.tag = l.tag),
                      t.anchor !== null && (t.anchorMap[t.anchor] = t.result);
                    break;
                  }
              } else
                R.call(t.typeMap, t.tag)
                  ? ((l = t.typeMap[t.tag]),
                    t.result !== null &&
                      l.kind !== t.kind &&
                      d(
                        t,
                        `unacceptable node kind for !<${t.tag}> tag; it should be "${l.kind}", not "${t.kind}"`,
                      ),
                    l.resolve(t.result)
                      ? ((t.result = l.construct(t.result)),
                        t.anchor !== null && (t.anchorMap[t.anchor] = t.result))
                      : d(
                          t,
                          `cannot resolve a node with !<${t.tag}> explicit tag`,
                        ))
                  : d(t, `unknown tag !<${t.tag}>`);
            return t.tag !== null || t.anchor !== null || y;
          }
          function M(t) {
            let e;
            let n;
            let a;
            let s;
            const c = t.position;
            let u = !1;
            for (
              t.version = null,
                t.checkLineBreaks = t.legacy,
                t.tagMap = {},
                t.anchorMap = {};
              (s = t.input.charCodeAt(t.position)) !== 0 &&
              (A(t, !0, -1),
              (s = t.input.charCodeAt(t.position)),
              !(t.lineIndent > 0 || s !== 37));

            ) {
              for (
                u = !0, s = t.input.charCodeAt(++t.position), e = t.position;
                s !== 0 && !o(s);

              )
                s = t.input.charCodeAt(++t.position);
              for (
                n = t.input.slice(e, t.position),
                  a = [],
                  n.length < 1 &&
                    d(
                      t,
                      "directive name must not be less than one character in length",
                    );
                s !== 0;

              ) {
                for (; r(s); ) s = t.input.charCodeAt(++t.position);
                if (s === 35) {
                  do s = t.input.charCodeAt(++t.position);
                  while (s !== 0 && !i(s));
                  break;
                }
                if (i(s)) break;
                for (e = t.position; s !== 0 && !o(s); )
                  s = t.input.charCodeAt(++t.position);
                a.push(t.input.slice(e, t.position));
              }
              s !== 0 && x(t),
                R.call(st, n)
                  ? st[n](t, n, a)
                  : m(t, `unknown document directive "${n}"`);
            }
            return (
              A(t, !0, -1),
              t.lineIndent === 0 &&
              t.input.charCodeAt(t.position) === 45 &&
              t.input.charCodeAt(t.position + 1) === 45 &&
              t.input.charCodeAt(t.position + 2) === 45
                ? ((t.position += 3), A(t, !0, -1))
                : u && d(t, "directives end mark is expected"),
              T(t, t.lineIndent - 1, Z, !1, !0),
              A(t, !0, -1),
              t.checkLineBreaks &&
                tt.test(t.input.slice(c, t.position)) &&
                m(t, "non-ASCII line breaks are interpreted as content"),
              t.documents.push(t.result),
              t.position === t.lineStart && b(t)
                ? void (
                    t.input.charCodeAt(t.position) === 46 &&
                    ((t.position += 3), A(t, !0, -1))
                  )
                : void (
                    t.position < t.length - 1 &&
                    d(
                      t,
                      "end of the stream or a document separator is expected",
                    )
                  )
            );
          }
          function L(t, e) {
            (t = String(t)),
              (e = e || {}),
              t.length !== 0 &&
                (t.charCodeAt(t.length - 1) !== 10 &&
                  t.charCodeAt(t.length - 1) !== 13 &&
                  (t += "\n"),
                t.charCodeAt(0) === 65279 && (t = t.slice(1)));
            const n = new f(t, e);
            for (n.input += "\0"; n.input.charCodeAt(n.position) === 32; )
              (n.lineIndent += 1), (n.position += 1);
            for (; n.position < n.length - 1; ) M(n);
            return n.documents;
          }
          function D(t, e, n) {
            let i;
            let r;
            const o = L(t, n);
            for (i = 0, r = o.length; r > i; i += 1) e(o[i]);
          }
          function U(t, e) {
            const n = L(t, e);
            if (n.length !== 0) {
              if (n.length === 1) return n[0];
              throw new B(
                "expected a single document in the stream, but found more",
              );
            }
          }
          function q(t, e, n) {
            D(t, e, P.extend({ schema: K }, n));
          }
          function Y(t, e) {
            return U(t, P.extend({ schema: K }, e));
          }
          for (
            var P = t("./common"),
              B = t("./exception"),
              $ = t("./mark"),
              K = t("./schema/default_safe"),
              H = t("./schema/default_full"),
              R = Object.prototype.hasOwnProperty,
              W = 1,
              G = 2,
              V = 3,
              Z = 4,
              z = 1,
              J = 2,
              Q = 3,
              X = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/,
              tt = /[\x85\u2028\u2029]/,
              et = /[,\[\]\{\}]/,
              nt = /^(?:!|!!|![a-z\-]+!)$/i,
              it = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i,
              rt = new Array(256),
              ot = new Array(256),
              at = 0;
            at < 256;
            at++
          )
            (rt[at] = l(at) ? 1 : 0), (ot[at] = l(at));
          var st = {
            YAML(t, e, n) {
              let i;
              let r;
              let o;
              t.version !== null && d(t, "duplication of %YAML directive"),
                n.length !== 1 &&
                  d(t, "YAML directive accepts exactly one argument"),
                (i = /^([0-9]+)\.([0-9]+)$/.exec(n[0])),
                i === null && d(t, "ill-formed argument of the YAML directive"),
                (r = parseInt(i[1], 10)),
                (o = parseInt(i[2], 10)),
                r !== 1 && d(t, "unacceptable YAML version of the document"),
                (t.version = n[0]),
                (t.checkLineBreaks = o < 2),
                o !== 1 &&
                  o !== 2 &&
                  m(t, "unsupported YAML version of the document");
            },
            TAG(t, e, n) {
              let i;
              let r;
              n.length !== 2 &&
                d(t, "TAG directive accepts exactly two arguments"),
                (i = n[0]),
                (r = n[1]),
                nt.test(i) ||
                  d(
                    t,
                    "ill-formed tag handle (first argument) of the TAG directive",
                  ),
                R.call(t.tagMap, i) &&
                  d(
                    t,
                    `there is a previously declared suffix for "${i}" tag handle`,
                  ),
                it.test(r) ||
                  d(
                    t,
                    "ill-formed tag prefix (second argument) of the TAG directive",
                  ),
                (t.tagMap[i] = r);
            },
          };
          (e.exports.loadAll = D),
            (e.exports.load = U),
            (e.exports.safeLoadAll = q),
            (e.exports.safeLoad = Y);
        },
        {
          "./common": 2,
          "./exception": 4,
          "./mark": 6,
          "./schema/default_full": 9,
          "./schema/default_safe": 10,
        },
      ],
      6: [
        function(t, e, n) {
          function i(t, e, n, i, r) {
            (this.name = t),
              (this.buffer = e),
              (this.position = n),
              (this.line = i),
              (this.column = r);
          }
          const r = t("./common");
          (i.prototype.getSnippet = function(t, e) {
            let n;
            let i;
            let o;
            let a;
            let s;
            if (!this.buffer) return null;
            for (
              t = t || 4, e = e || 75, n = "", i = this.position;
              i > 0 &&
              "\0\r\nÂ…\u2028\u2029".indexOf(this.buffer.charAt(i - 1)) === -1;

            )
              if (((i -= 1), this.position - i > e / 2 - 1)) {
                (n = " ... "), (i += 5);
                break;
              }
            for (
              o = "", a = this.position;
              a < this.buffer.length &&
              "\0\r\nÂ…\u2028\u2029".indexOf(this.buffer.charAt(a)) === -1;

            )
              if (((a += 1), a - this.position > e / 2 - 1)) {
                (o = " ... "), (a -= 5);
                break;
              }
            return (
              (s = this.buffer.slice(i, a)),
              `${r.repeat(" ", t) + n + s + o}\n${r.repeat(
                " ",
                t + this.position - i + n.length,
              )}^`
            );
          }),
            (i.prototype.toString = function(t) {
              let e;
              let n = "";
              return (
                this.name && (n += `in "${this.name}" `),
                (n += `at line ${this.line + 1}, column ${this.column + 1}`),
                t || ((e = this.getSnippet()), e && (n += `:\n${e}`)),
                n
              );
            }),
            (e.exports = i);
        },
        { "./common": 2 },
      ],
      7: [
        function(t, e, n) {
          function i(t, e, n) {
            const r = [];
            return (
              t.include.forEach(function(t) {
                n = i(t, e, n);
              }),
              t[e].forEach(function(t) {
                n.forEach(function(e, n) {
                  e.tag === t.tag && r.push(n);
                }),
                  n.push(t);
              }),
              n.filter(function(t, e) {
                return r.indexOf(e) === -1;
              })
            );
          }
          function r() {
            function t(t) {
              i[t.tag] = t;
            }
            let e;
            let n;
            var i = {};
            for (e = 0, n = arguments.length; n > e; e += 1)
              arguments[e].forEach(t);
            return i;
          }
          function o(t) {
            (this.include = t.include || []),
              (this.implicit = t.implicit || []),
              (this.explicit = t.explicit || []),
              this.implicit.forEach(function(t) {
                if (t.loadKind && t.loadKind !== "scalar")
                  throw new s(
                    "There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.",
                  );
              }),
              (this.compiledImplicit = i(this, "implicit", [])),
              (this.compiledExplicit = i(this, "explicit", [])),
              (this.compiledTypeMap = r(
                this.compiledImplicit,
                this.compiledExplicit,
              ));
          }
          const a = t("./common");
          var s = t("./exception");
          const c = t("./type");
          (o.DEFAULT = null),
            (o.create = function() {
              let t;
              let e;
              switch (arguments.length) {
                case 1:
                  (t = o.DEFAULT), (e = arguments[0]);
                  break;
                case 2:
                  (t = arguments[0]), (e = arguments[1]);
                  break;
                default:
                  throw new s(
                    "Wrong number of arguments for Schema.create function",
                  );
              }
              if (
                ((t = a.toArray(t)),
                (e = a.toArray(e)),
                !t.every(function(t) {
                  return t instanceof o;
                }))
              )
                throw new s(
                  "Specified list of super schemas (or a single Schema object) contains a non-Schema object.",
                );
              if (
                !e.every(function(t) {
                  return t instanceof c;
                })
              )
                throw new s(
                  "Specified list of YAML types (or a single Type object) contains a non-Type object.",
                );
              return new o({ include: t, explicit: e });
            }),
            (e.exports = o);
        },
        { "./common": 2, "./exception": 4, "./type": 13 },
      ],
      8: [
        function(t, e, n) {
          const i = t("../schema");
          e.exports = new i({ include: [t("./json")] });
        },
        { "../schema": 7, "./json": 12 },
      ],
      9: [
        function(t, e, n) {
          const i = t("../schema");
          e.exports = i.DEFAULT = new i({
            include: [t("./default_safe")],
            explicit: [
              t("../type/js/undefined"),
              t("../type/js/regexp"),
              t("../type/js/function"),
            ],
          });
        },
        {
          "../schema": 7,
          "../type/js/function": 18,
          "../type/js/regexp": 19,
          "../type/js/undefined": 20,
          "./default_safe": 10,
        },
      ],
      10: [
        function(t, e, n) {
          const i = t("../schema");
          e.exports = new i({
            include: [t("./core")],
            implicit: [t("../type/timestamp"), t("../type/merge")],
            explicit: [
              t("../type/binary"),
              t("../type/omap"),
              t("../type/pairs"),
              t("../type/set"),
            ],
          });
        },
        {
          "../schema": 7,
          "../type/binary": 14,
          "../type/merge": 22,
          "../type/omap": 24,
          "../type/pairs": 25,
          "../type/set": 27,
          "../type/timestamp": 29,
          "./core": 8,
        },
      ],
      11: [
        function(t, e, n) {
          const i = t("../schema");
          e.exports = new i({
            explicit: [t("../type/str"), t("../type/seq"), t("../type/map")],
          });
        },
        {
          "../schema": 7,
          "../type/map": 21,
          "../type/seq": 26,
          "../type/str": 28,
        },
      ],
      12: [
        function(t, e, n) {
          const i = t("../schema");
          e.exports = new i({
            include: [t("./failsafe")],
            implicit: [
              t("../type/null"),
              t("../type/bool"),
              t("../type/int"),
              t("../type/float"),
            ],
          });
        },
        {
          "../schema": 7,
          "../type/bool": 15,
          "../type/float": 16,
          "../type/int": 17,
          "../type/null": 23,
          "./failsafe": 11,
        },
      ],
      13: [
        function(t, e, n) {
          function i(t) {
            const e = {};
            return (
              t !== null &&
                Object.keys(t).forEach(function(n) {
                  t[n].forEach(function(t) {
                    e[String(t)] = n;
                  });
                }),
              e
            );
          }
          function r(t, e) {
            if (
              ((e = e || {}),
              Object.keys(e).forEach(function(e) {
                if (a.indexOf(e) === -1)
                  throw new o(
                    `Unknown option "${e}" is met in definition of "${t}" YAML type.`,
                  );
              }),
              (this.tag = t),
              (this.kind = e.kind || null),
              (this.resolve =
                e.resolve ||
                function() {
                  return !0;
                }),
              (this.construct =
                e.construct ||
                function(t) {
                  return t;
                }),
              (this.instanceOf = e.instanceOf || null),
              (this.predicate = e.predicate || null),
              (this.represent = e.represent || null),
              (this.defaultStyle = e.defaultStyle || null),
              (this.styleAliases = i(e.styleAliases || null)),
              s.indexOf(this.kind) === -1)
            )
              throw new o(
                `Unknown kind "${this.kind}" is specified for "${t}" YAML type.`,
              );
          }
          var o = t("./exception");
          var a = [
            "kind",
            "resolve",
            "construct",
            "instanceOf",
            "predicate",
            "represent",
            "defaultStyle",
            "styleAliases",
          ];
          var s = ["scalar", "sequence", "mapping"];
          e.exports = r;
        },
        { "./exception": 4 },
      ],
      14: [
        function(t, e, n) {
          function i(t) {
            if (t === null) return !1;
            let e;
            let n;
            let i = 0;
            const r = t.length;
            const o = u;
            for (n = 0; r > n; n++)
              if (((e = o.indexOf(t.charAt(n))), !(e > 64))) {
                if (e < 0) return !1;
                i += 6;
              }
            return i % 8 === 0;
          }
          function r(t) {
            let e;
            let n;
            const i = t.replace(/[\r\n=]/g, "");
            const r = i.length;
            const o = u;
            let a = 0;
            const c = [];
            for (e = 0; r > e; e++)
              e % 4 === 0 &&
                e &&
                (c.push((a >> 16) & 255),
                c.push((a >> 8) & 255),
                c.push(255 & a)),
                (a = (a << 6) | o.indexOf(i.charAt(e)));
            return (
              (n = (r % 4) * 6),
              n === 0
                ? (c.push((a >> 16) & 255),
                  c.push((a >> 8) & 255),
                  c.push(255 & a))
                : n === 18
                ? (c.push((a >> 10) & 255), c.push((a >> 2) & 255))
                : n === 12 && c.push((a >> 4) & 255),
              s ? new s(c) : c
            );
          }
          function o(t) {
            let e;
            let n;
            let i = "";
            let r = 0;
            const o = t.length;
            const a = u;
            for (e = 0; o > e; e++)
              e % 3 === 0 &&
                e &&
                ((i += a[(r >> 18) & 63]),
                (i += a[(r >> 12) & 63]),
                (i += a[(r >> 6) & 63]),
                (i += a[63 & r])),
                (r = (r << 8) + t[e]);
            return (
              (n = o % 3),
              n === 0
                ? ((i += a[(r >> 18) & 63]),
                  (i += a[(r >> 12) & 63]),
                  (i += a[(r >> 6) & 63]),
                  (i += a[63 & r]))
                : n === 2
                ? ((i += a[(r >> 10) & 63]),
                  (i += a[(r >> 4) & 63]),
                  (i += a[(r << 2) & 63]),
                  (i += a[64]))
                : n === 1 &&
                  ((i += a[(r >> 2) & 63]),
                  (i += a[(r << 4) & 63]),
                  (i += a[64]),
                  (i += a[64])),
              i
            );
          }
          function a(t) {
            return s && s.isBuffer(t);
          }
          var s = t("buffer").Buffer;
          const c = t("../type");
          var u =
            "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r";
          e.exports = new c("tag:yaml.org,2002:binary", {
            kind: "scalar",
            resolve: i,
            construct: r,
            predicate: a,
            represent: o,
          });
        },
        { "../type": 13, buffer: 30 },
      ],
      15: [
        function(t, e, n) {
          function i(t) {
            if (t === null) return !1;
            const e = t.length;
            return (
              (e === 4 && (t === "true" || t === "True" || t === "TRUE")) ||
              (e === 5 && (t === "false" || t === "False" || t === "FALSE"))
            );
          }
          function r(t) {
            return t === "true" || t === "True" || t === "TRUE";
          }
          function o(t) {
            return Object.prototype.toString.call(t) === "[object Boolean]";
          }
          const a = t("../type");
          e.exports = new a("tag:yaml.org,2002:bool", {
            kind: "scalar",
            resolve: i,
            construct: r,
            predicate: o,
            represent: {
              lowercase(t) {
                return t ? "true" : "false";
              },
              uppercase(t) {
                return t ? "TRUE" : "FALSE";
              },
              camelcase(t) {
                return t ? "True" : "False";
              },
            },
            defaultStyle: "lowercase",
          });
        },
        { "../type": 13 },
      ],
      16: [
        function(t, e, n) {
          function i(t) {
            return t !== null && !!u.test(t);
          }
          function r(t) {
            let e;
            let n;
            let i;
            let r;
            return (
              (e = t.replace(/_/g, "").toLowerCase()),
              (n = e[0] === "-" ? -1 : 1),
              (r = []),
              "+-".indexOf(e[0]) >= 0 && (e = e.slice(1)),
              e === ".inf"
                ? n === 1
                  ? Number.POSITIVE_INFINITY
                  : Number.NEGATIVE_INFINITY
                : e === ".nan"
                ? NaN
                : e.indexOf(":") >= 0
                ? (e.split(":").forEach(function(t) {
                    r.unshift(parseFloat(t, 10));
                  }),
                  (e = 0),
                  (i = 1),
                  r.forEach(function(t) {
                    (e += t * i), (i *= 60);
                  }),
                  n * e)
                : n * parseFloat(e, 10)
            );
          }
          function o(t, e) {
            let n;
            if (isNaN(t))
              switch (e) {
                case "lowercase":
                  return ".nan";
                case "uppercase":
                  return ".NAN";
                case "camelcase":
                  return ".NaN";
              }
            else if (Number.POSITIVE_INFINITY === t)
              switch (e) {
                case "lowercase":
                  return ".inf";
                case "uppercase":
                  return ".INF";
                case "camelcase":
                  return ".Inf";
              }
            else if (Number.NEGATIVE_INFINITY === t)
              switch (e) {
                case "lowercase":
                  return "-.inf";
                case "uppercase":
                  return "-.INF";
                case "camelcase":
                  return "-.Inf";
              }
            else if (s.isNegativeZero(t)) return "-0.0";
            return (n = t.toString(10)), l.test(n) ? n.replace("e", ".e") : n;
          }
          function a(t) {
            return (
              Object.prototype.toString.call(t) === "[object Number]" &&
              (t % 1 !== 0 || s.isNegativeZero(t))
            );
          }
          var s = t("../common");
          const c = t("../type");
          var u = new RegExp(
            "^(?:[-+]?(?:[0-9][0-9_]*)\\.[0-9_]*(?:[eE][-+][0-9]+)?|\\.[0-9_]+(?:[eE][-+][0-9]+)?|[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$",
          );
          var l = /^[-+]?[0-9]+e/;
          e.exports = new c("tag:yaml.org,2002:float", {
            kind: "scalar",
            resolve: i,
            construct: r,
            predicate: a,
            represent: o,
            defaultStyle: "lowercase",
          });
        },
        { "../common": 2, "../type": 13 },
      ],
      17: [
        function(t, e, n) {
          function i(t) {
            return (
              (t >= 48 && t <= 57) ||
              (t >= 65 && t <= 70) ||
              (t >= 97 && t <= 102)
            );
          }
          function r(t) {
            return t >= 48 && t <= 55;
          }
          function o(t) {
            return t >= 48 && t <= 57;
          }
          function a(t) {
            if (t === null) return !1;
            let e;
            const n = t.length;
            let a = 0;
            let s = !1;
            if (!n) return !1;
            if (
              ((e = t[a]), (e === "-" || e === "+") && (e = t[++a]), e === "0")
            ) {
              if (a + 1 === n) return !0;
              if (((e = t[++a]), e === "b")) {
                for (a++; n > a; a++)
                  if (((e = t[a]), e !== "_")) {
                    if (e !== "0" && e !== "1") return !1;
                    s = !0;
                  }
                return s;
              }
              if (e === "x") {
                for (a++; n > a; a++)
                  if (((e = t[a]), e !== "_")) {
                    if (!i(t.charCodeAt(a))) return !1;
                    s = !0;
                  }
                return s;
              }
              for (; n > a; a++)
                if (((e = t[a]), e !== "_")) {
                  if (!r(t.charCodeAt(a))) return !1;
                  s = !0;
                }
              return s;
            }
            for (; n > a; a++)
              if (((e = t[a]), e !== "_")) {
                if (e === ":") break;
                if (!o(t.charCodeAt(a))) return !1;
                s = !0;
              }
            return !!s && (e !== ":" || /^(:[0-5]?[0-9])+$/.test(t.slice(a)));
          }
          function s(t) {
            let e;
            let n;
            let i = t;
            let r = 1;
            const o = [];
            return (
              i.indexOf("_") !== -1 && (i = i.replace(/_/g, "")),
              (e = i[0]),
              (e === "-" || e === "+") &&
                (e === "-" && (r = -1), (i = i.slice(1)), (e = i[0])),
              i === "0"
                ? 0
                : e === "0"
                ? i[1] === "b"
                  ? r * parseInt(i.slice(2), 2)
                  : i[1] === "x"
                  ? r * parseInt(i, 16)
                  : r * parseInt(i, 8)
                : i.indexOf(":") !== -1
                ? (i.split(":").forEach(function(t) {
                    o.unshift(parseInt(t, 10));
                  }),
                  (i = 0),
                  (n = 1),
                  o.forEach(function(t) {
                    (i += t * n), (n *= 60);
                  }),
                  r * i)
                : r * parseInt(i, 10)
            );
          }
          function c(t) {
            return (
              Object.prototype.toString.call(t) === "[object Number]" &&
              t % 1 === 0 &&
              !u.isNegativeZero(t)
            );
          }
          var u = t("../common");
          const l = t("../type");
          e.exports = new l("tag:yaml.org,2002:int", {
            kind: "scalar",
            resolve: a,
            construct: s,
            predicate: c,
            represent: {
              binary(t) {
                return `0b${t.toString(2)}`;
              },
              octal(t) {
                return `0${t.toString(8)}`;
              },
              decimal(t) {
                return t.toString(10);
              },
              hexadecimal(t) {
                return `0x${t.toString(16).toUpperCase()}`;
              },
            },
            defaultStyle: "decimal",
            styleAliases: {
              binary: [2, "bin"],
              octal: [8, "oct"],
              decimal: [10, "dec"],
              hexadecimal: [16, "hex"],
            },
          });
        },
        { "../common": 2, "../type": 13 },
      ],
      18: [
        function(t, e, n) {
          function i(t) {
            if (t === null) return !1;
            try {
              const e = `(${t})`;
              const n = s.parse(e, { range: !0 });
              return (
                n.type === "Program" &&
                n.body.length === 1 &&
                n.body[0].type === "ExpressionStatement" &&
                n.body[0].expression.type === "FunctionExpression"
              );
            } catch (i) {
              return !1;
            }
          }
          function r(t) {
            let e;
            const n = `(${t})`;
            const i = s.parse(n, { range: !0 });
            const r = [];
            if (
              i.type !== "Program" ||
              i.body.length !== 1 ||
              i.body[0].type !== "ExpressionStatement" ||
              i.body[0].expression.type !== "FunctionExpression"
            )
              throw new Error("Failed to resolve function");
            return (
              i.body[0].expression.params.forEach(function(t) {
                r.push(t.name);
              }),
              (e = i.body[0].expression.body.range),
              new Function(r, n.slice(e[0] + 1, e[1] - 1))
            );
          }
          function o(t) {
            return t.toString();
          }
          function a(t) {
            return Object.prototype.toString.call(t) === "[object Function]";
          }
          let s;
          try {
            s = t("esprima");
          } catch (c) {
            typeof window !== "undefined" && (s = window.esprima);
          }
          const u = t("../../type");
          e.exports = new u("tag:yaml.org,2002:js/function", {
            kind: "scalar",
            resolve: i,
            construct: r,
            predicate: a,
            represent: o,
          });
        },
        { "../../type": 13, esprima: "esprima" },
      ],
      19: [
        function(t, e, n) {
          function i(t) {
            if (t === null) return !1;
            if (t.length === 0) return !1;
            let e = t;
            const n = /\/([gim]*)$/.exec(t);
            let i = "";
            if (e[0] === "/") {
              if ((n && (i = n[1]), i.length > 3)) return !1;
              if (e[e.length - i.length - 1] !== "/") return !1;
              e = e.slice(1, e.length - i.length - 1);
            }
            try {
              return !0;
            } catch (r) {
              return !1;
            }
          }
          function r(t) {
            let e = t;
            const n = /\/([gim]*)$/.exec(t);
            let i = "";
            return (
              e[0] === "/" &&
                (n && (i = n[1]), (e = e.slice(1, e.length - i.length - 1))),
              new RegExp(e, i)
            );
          }
          function o(t) {
            let e = `/${t.source}/`;
            return (
              t.global && (e += "g"),
              t.multiline && (e += "m"),
              t.ignoreCase && (e += "i"),
              e
            );
          }
          function a(t) {
            return Object.prototype.toString.call(t) === "[object RegExp]";
          }
          const s = t("../../type");
          e.exports = new s("tag:yaml.org,2002:js/regexp", {
            kind: "scalar",
            resolve: i,
            construct: r,
            predicate: a,
            represent: o,
          });
        },
        { "../../type": 13 },
      ],
      20: [
        function(t, e, n) {
          function i() {
            return !0;
          }
          function r() {}
          function o() {
            return "";
          }
          function a(t) {
            return typeof t === "undefined";
          }
          const s = t("../../type");
          e.exports = new s("tag:yaml.org,2002:js/undefined", {
            kind: "scalar",
            resolve: i,
            construct: r,
            predicate: a,
            represent: o,
          });
        },
        { "../../type": 13 },
      ],
      21: [
        function(t, e, n) {
          const i = t("../type");
          e.exports = new i("tag:yaml.org,2002:map", {
            kind: "mapping",
            construct(t) {
              return t !== null ? t : {};
            },
          });
        },
        { "../type": 13 },
      ],
      22: [
        function(t, e, n) {
          function i(t) {
            return t === "<<" || t === null;
          }
          const r = t("../type");
          e.exports = new r("tag:yaml.org,2002:merge", {
            kind: "scalar",
            resolve: i,
          });
        },
        { "../type": 13 },
      ],
      23: [
        function(t, e, n) {
          function i(t) {
            if (t === null) return !0;
            const e = t.length;
            return (
              (e === 1 && t === "~") ||
              (e === 4 && (t === "null" || t === "Null" || t === "NULL"))
            );
          }
          function r() {
            return null;
          }
          function o(t) {
            return t === null;
          }
          const a = t("../type");
          e.exports = new a("tag:yaml.org,2002:null", {
            kind: "scalar",
            resolve: i,
            construct: r,
            predicate: o,
            represent: {
              canonical() {
                return "~";
              },
              lowercase() {
                return "null";
              },
              uppercase() {
                return "NULL";
              },
              camelcase() {
                return "Null";
              },
            },
            defaultStyle: "lowercase",
          });
        },
        { "../type": 13 },
      ],
      24: [
        function(t, e, n) {
          function i(t) {
            if (t === null) return !0;
            let e;
            let n;
            let i;
            let r;
            let o;
            const c = [];
            const u = t;
            for (e = 0, n = u.length; n > e; e += 1) {
              if (((i = u[e]), (o = !1), s.call(i) !== "[object Object]"))
                return !1;
              for (r in i)
                if (a.call(i, r)) {
                  if (o) return !1;
                  o = !0;
                }
              if (!o) return !1;
              if (c.indexOf(r) !== -1) return !1;
              c.push(r);
            }
            return !0;
          }
          function r(t) {
            return t !== null ? t : [];
          }
          const o = t("../type");
          var a = Object.prototype.hasOwnProperty;
          var s = Object.prototype.toString;
          e.exports = new o("tag:yaml.org,2002:omap", {
            kind: "sequence",
            resolve: i,
            construct: r,
          });
        },
        { "../type": 13 },
      ],
      25: [
        function(t, e, n) {
          function i(t) {
            if (t === null) return !0;
            let e;
            let n;
            let i;
            let r;
            let o;
            const s = t;
            for (o = new Array(s.length), e = 0, n = s.length; n > e; e += 1) {
              if (((i = s[e]), a.call(i) !== "[object Object]")) return !1;
              if (((r = Object.keys(i)), r.length !== 1)) return !1;
              o[e] = [r[0], i[r[0]]];
            }
            return !0;
          }
          function r(t) {
            if (t === null) return [];
            let e;
            let n;
            let i;
            let r;
            let o;
            const a = t;
            for (o = new Array(a.length), e = 0, n = a.length; n > e; e += 1)
              (i = a[e]), (r = Object.keys(i)), (o[e] = [r[0], i[r[0]]]);
            return o;
          }
          const o = t("../type");
          var a = Object.prototype.toString;
          e.exports = new o("tag:yaml.org,2002:pairs", {
            kind: "sequence",
            resolve: i,
            construct: r,
          });
        },
        { "../type": 13 },
      ],
      26: [
        function(t, e, n) {
          const i = t("../type");
          e.exports = new i("tag:yaml.org,2002:seq", {
            kind: "sequence",
            construct(t) {
              return t !== null ? t : [];
            },
          });
        },
        { "../type": 13 },
      ],
      27: [
        function(t, e, n) {
          function i(t) {
            if (t === null) return !0;
            let e;
            const n = t;
            for (e in n) if (a.call(n, e) && n[e] !== null) return !1;
            return !0;
          }
          function r(t) {
            return t !== null ? t : {};
          }
          const o = t("../type");
          var a = Object.prototype.hasOwnProperty;
          e.exports = new o("tag:yaml.org,2002:set", {
            kind: "mapping",
            resolve: i,
            construct: r,
          });
        },
        { "../type": 13 },
      ],
      28: [
        function(t, e, n) {
          const i = t("../type");
          e.exports = new i("tag:yaml.org,2002:str", {
            kind: "scalar",
            construct(t) {
              return t !== null ? t : "";
            },
          });
        },
        { "../type": 13 },
      ],
      29: [
        function(t, e, n) {
          function i(t) {
            return t !== null && s.exec(t) !== null;
          }
          function r(t) {
            let e;
            let n;
            let i;
            let r;
            let o;
            let a;
            let c;
            let u;
            let l;
            let p;
            let f = 0;
            let h = null;
            if (((e = s.exec(t)), e === null))
              throw new Error("Date resolve error");
            if (((n = +e[1]), (i = +e[2] - 1), (r = +e[3]), !e[4]))
              return new Date(Date.UTC(n, i, r));
            if (((o = +e[4]), (a = +e[5]), (c = +e[6]), e[7])) {
              for (f = e[7].slice(0, 3); f.length < 3; ) f += "0";
              f = +f;
            }
            return (
              e[9] &&
                ((u = +e[10]),
                (l = +(e[11] || 0)),
                (h = 6e4 * (60 * u + l)),
                e[9] === "-" && (h = -h)),
              (p = new Date(Date.UTC(n, i, r, o, a, c, f))),
              h && p.setTime(p.getTime() - h),
              p
            );
          }
          function o(t) {
            return t.toISOString();
          }
          const a = t("../type");
          var s = new RegExp(
            "^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?)?$",
          );
          e.exports = new a("tag:yaml.org,2002:timestamp", {
            kind: "scalar",
            resolve: i,
            construct: r,
            instanceOf: Date,
            represent: o,
          });
        },
        { "../type": 13 },
      ],
      30: [function(t, e, n) {}, {}],
      31: [
        function(t, e, n) {
          e.exports = t("./lib/inherit");
        },
        { "./lib/inherit": 32 },
      ],
      32: [
        function(e, n, i) {
          !(function(e) {
            function r(t) {
              const e = f(t);
              if (v)
                for (var n, i = 0; (n = b[i++]); )
                  t.hasOwnProperty(n) && e.push(n);
              return e;
            }
            function o(t, e, n) {
              for (var i, o, a = r(n), s = 0, u = a.length; u > s; )
                (i = a[s++]) !== "__self" &&
                  ((o = n[i]),
                  y(o) && (!c || o.toString().indexOf(".__base") > -1)
                    ? (e[i] = (function(n, i) {
                        const r = t[n]
                          ? t[n]
                          : n === "__constructor"
                          ? e.__self.__parent
                          : g;
                        return function() {
                          const t = this.__base;
                          this.__base = r;
                          const e = i.apply(this, arguments);
                          return (this.__base = t), e;
                        };
                      })(i, o))
                    : (e[i] = o));
            }
            function a(t, e) {
              for (var n, i = 1; (n = t[i++]); )
                e
                  ? y(n)
                    ? s.self(e, n.prototype, n)
                    : s.self(e, n)
                  : (e = y(n) ? s(t[0], n.prototype, n) : s(t[0], n));
              return e || t[0];
            }
            function s() {
              const t = arguments;
              const e = m(t[0]);
              const n = e || y(t[0]);
              const i = n ? (e ? a(t[0]) : t[0]) : u;
              const r = t[n ? 1 : 0] || {};
              const s = t[n ? 2 : 1];
              const c =
                r.__constructor || (n && i.prototype.__constructor)
                  ? function() {
                      return this.__constructor.apply(this, arguments);
                    }
                  : n
                  ? function() {
                      return i.apply(this, arguments);
                    }
                  : function() {};
              if (!n)
                return (
                  (c.prototype = r),
                  (c.prototype.__self = c.prototype.constructor = c),
                  h(c, s)
                );
              h(c, i), (c.__parent = i);
              const l = i.prototype;
              const f = (c.prototype = p(l));
              return (
                (f.__self = f.constructor = c),
                r && o(l, f, r),
                s && o(i, c, s),
                c
              );
            }
            var c = function() {}.toString().indexOf("_") > -1;
            var u = function() {};
            const l = Object.prototype.hasOwnProperty;
            var p =
              Object.create ||
              function(t) {
                const e = function() {};
                return (e.prototype = t), new e();
              };
            var f =
              Object.keys ||
              function(t) {
                const e = [];
                for (const n in t) l.call(t, n) && e.push(n);
                return e;
              };
            var h = function(t, e) {
              for (const n in e) l.call(e, n) && (t[n] = e[n]);
              return t;
            };
            const d = Object.prototype.toString;
            var m =
              Array.isArray ||
              function(t) {
                return d.call(t) === "[object Array]";
              };
            var y = function(t) {
              return d.call(t) === "[object Function]";
            };
            var g = function() {};
            var v = !0;
            const x = { toString: "" };
            for (const A in x) x.hasOwnProperty(A) && (v = !1);
            var b = v ? ["toString", "valueOf"] : null;
            s.self = function() {
              const t = arguments;
              const e = m(t[0]);
              const n = e ? a(t[0], t[0][0]) : t[0];
              const i = t[1];
              const r = t[2];
              const s = n.prototype;
              return i && o(s, s, i), r && o(n, n, r), n;
            };
            let w = !0;
            typeof i === "object" && ((n.exports = s), (w = !1)),
              typeof modules === "object" &&
                (modules.define("inherit", function(t) {
                  t(s);
                }),
                (w = !1)),
              typeof t === "function" &&
                (t(function(t, e, n) {
                  n.exports = s;
                }),
                (w = !1)),
              w && (e.inherit = s);
          })(this);
        },
        {},
      ],
      "/": [
        function(t, e, n) {
          const i = t("./lib/js-yaml.js");
          e.exports = i;
        },
        { "./lib/js-yaml.js": 1 },
      ],
    },
    {},
    [],
  )("/");
});
