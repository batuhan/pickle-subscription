/*
 * jQuery Storage API Plugin
 *
 * Copyright (c) 2013 Julien Maurel
 *
 * Licensed under the MIT license:
 * http://www.opensource.org/licenses/mit-license.php
 *
 * Project home:
 * https://github.com/julien-maurel/jQuery-Storage-API
 *
 * Version: 1.9.4
 */
!(function(e) {
  typeof define === "function" && define.amd
    ? define(["jquery"], e)
    : e(typeof exports === "object" ? require("jquery") : jQuery);
})(function(e) {
  function t() {
    let t;
    let r;
    let i;
    const o = this._type;
    const n = arguments.length;
    const s = window[o];
    const a = arguments;
    const f = a[0];
    if (n < 1) throw new Error("Minimum 1 argument must be given");
    if (e.isArray(f)) {
      r = {};
      for (var l in f) {
        t = f[l];
        try {
          r[t] = JSON.parse(s.getItem(t));
        } catch (c) {
          r[t] = s.getItem(t);
        }
      }
      return r;
    }
    if (n != 1) {
      try {
        r = JSON.parse(s.getItem(f));
      } catch (c) {
        throw new ReferenceError(`${f} is not defined in this storage`);
      }
      for (var l = 1; n - 1 > l; l++)
        if (((r = r[a[l]]), void 0 === r))
          throw new ReferenceError(
            `${[].slice
              .call(a, 1, l + 1)
              .join(".")} is not defined in this storage`,
          );
      if (e.isArray(a[l])) {
        (i = r), (r = {});
        for (const u in a[l]) r[a[l][u]] = i[a[l][u]];
        return r;
      }
      return r[a[l]];
    }
    try {
      return JSON.parse(s.getItem(f));
    } catch (c) {
      return s.getItem(f);
    }
  }
  function r() {
    let t;
    let r;
    let i;
    const o = this._type;
    const n = arguments.length;
    const s = window[o];
    const a = arguments;
    const f = a[0];
    const l = a[1];
    let c = isNaN(l) ? {} : [];
    if (n < 1 || (!e.isPlainObject(f) && n < 2))
      throw new Error(
        "Minimum 2 arguments must be given or first parameter must be an object",
      );
    if (e.isPlainObject(f)) {
      for (var u in f)
        (t = f[u]),
          e.isPlainObject(t) || this.alwaysUseJson
            ? s.setItem(u, JSON.stringify(t))
            : s.setItem(u, t);
      return f;
    }
    if (n == 2)
      return (
        typeof l === "object" || this.alwaysUseJson
          ? s.setItem(f, JSON.stringify(l))
          : s.setItem(f, l),
        l
      );
    try {
      (i = s.getItem(f)), i != null && (c = JSON.parse(i));
    } catch (h) {}
    i = c;
    for (var u = 1; n - 2 > u; u++)
      (t = a[u]),
        (r = isNaN(a[u + 1]) ? "object" : "array"),
        (!i[t] ||
          (r == "object" && !e.isPlainObject(i[t])) ||
          (r == "array" && !e.isArray(i[t]))) &&
          (r == "array" ? (i[t] = []) : (i[t] = {})),
        (i = i[t]);
    return (i[a[u]] = a[u + 1]), s.setItem(f, JSON.stringify(c)), c;
  }
  function i() {
    let t;
    let r;
    const i = this._type;
    const o = arguments.length;
    const n = window[i];
    const s = arguments;
    const a = s[0];
    if (o < 1) throw new Error("Minimum 1 argument must be given");
    if (e.isArray(a)) {
      for (var f in a) n.removeItem(a[f]);
      return !0;
    }
    if (o == 1) return n.removeItem(a), !0;
    try {
      t = r = JSON.parse(n.getItem(a));
    } catch (l) {
      throw new ReferenceError(`${a} is not defined in this storage`);
    }
    for (var f = 1; o - 1 > f; f++)
      if (((r = r[s[f]]), void 0 === r))
        throw new ReferenceError(
          `${[].slice.call(s, 1, f).join(".")} is not defined in this storage`,
        );
    if (e.isArray(s[f])) for (const c in s[f]) delete r[s[f][c]];
    else delete r[s[f]];
    return n.setItem(a, JSON.stringify(t)), !0;
  }
  function o(t) {
    const r = a.call(this);
    for (var o in r) i.call(this, r[o]);
    if (t) for (var o in e.namespaceStorages) f(o);
  }
  function n() {
    const r = arguments.length;
    const i = arguments;
    const o = i[0];
    if (r == 0) return a.call(this).length == 0;
    if (e.isArray(o)) {
      for (var s = 0; s < o.length; s++) if (!n.call(this, o[s])) return !1;
      return !0;
    }
    try {
      let f = t.apply(this, arguments);
      e.isArray(i[r - 1]) || (f = { totest: f });
      for (var s in f)
        if (
          !(
            (e.isPlainObject(f[s]) && e.isEmptyObject(f[s])) ||
            (e.isArray(f[s]) && !f[s].length)
          ) &&
          f[s]
        )
          return !1;
      return !0;
    } catch (l) {
      return !0;
    }
  }
  function s() {
    const r = arguments.length;
    const i = arguments;
    const o = i[0];
    if (r < 1) throw new Error("Minimum 1 argument must be given");
    if (e.isArray(o)) {
      for (var n = 0; n < o.length; n++) if (!s.call(this, o[n])) return !1;
      return !0;
    }
    try {
      let a = t.apply(this, arguments);
      e.isArray(i[r - 1]) || (a = { totest: a });
      for (var n in a) if (void 0 === a[n] || a[n] === null) return !1;
      return !0;
    } catch (f) {
      return !1;
    }
  }
  function a() {
    const e = this._type;
    const r = arguments.length;
    const i = window[e];
    const o = arguments;
    const n = [];
    let s = {};
    if (((s = r > 0 ? t.apply(this, o) : i), s && s._cookie))
      for (const a in Cookies.get())
        a != "" && n.push(a.replace(s._prefix, ""));
    else for (const f in s) s.hasOwnProperty(f) && n.push(f);
    return n;
  }
  function f(t) {
    if (!t || typeof t !== "string")
      throw new Error("First parameter must be a string");
    h
      ? (window.localStorage.getItem(t) || window.localStorage.setItem(t, "{}"),
        window.sessionStorage.getItem(t) ||
          window.sessionStorage.setItem(t, "{}"))
      : (window.localCookieStorage.getItem(t) ||
          window.localCookieStorage.setItem(t, "{}"),
        window.sessionCookieStorage.getItem(t) ||
          window.sessionCookieStorage.setItem(t, "{}"));
    const r = {
      localStorage: e.extend({}, e.localStorage, { _ns: t }),
      sessionStorage: e.extend({}, e.sessionStorage, { _ns: t }),
    };
    return (
      typeof Cookies !== "undefined" &&
        (window.cookieStorage.getItem(t) ||
          window.cookieStorage.setItem(t, "{}"),
        (r.cookieStorage = e.extend({}, e.cookieStorage, { _ns: t }))),
      (e.namespaceStorages[t] = r),
      r
    );
  }
  function l(e) {
    const t = "jsapi";
    try {
      return window[e]
        ? (window[e].setItem(t, t), window[e].removeItem(t), !0)
        : !1;
    } catch (r) {
      return !1;
    }
  }
  const c = "ls_";
  const u = "ss_";
  var h = l("localStorage");
  const g = {
    _type: "",
    _ns: "",
    _callMethod(e, t) {
      const r = [];
      var t = Array.prototype.slice.call(t);
      const i = t[0];
      return (
        this._ns && r.push(this._ns),
        typeof i === "string" &&
          i.indexOf(".") !== -1 &&
          (t.shift(), [].unshift.apply(t, i.split("."))),
        [].push.apply(r, t),
        e.apply(this, r)
      );
    },
    alwaysUseJson: !1,
    get() {
      return this._callMethod(t, arguments);
    },
    set() {
      const t = arguments.length;
      const i = arguments;
      const o = i[0];
      if (t < 1 || (!e.isPlainObject(o) && t < 2))
        throw new Error(
          "Minimum 2 arguments must be given or first parameter must be an object",
        );
      if (e.isPlainObject(o) && this._ns) {
        for (const n in o) this._callMethod(r, [n, o[n]]);
        return o;
      }
      const s = this._callMethod(r, i);
      return this._ns ? s[o.split(".")[0]] : s;
    },
    remove() {
      if (arguments.length < 1)
        throw new Error("Minimum 1 argument must be given");
      return this._callMethod(i, arguments);
    },
    removeAll(e) {
      return this._ns
        ? (this._callMethod(r, [{}]), !0)
        : this._callMethod(o, [e]);
    },
    isEmpty() {
      return this._callMethod(n, arguments);
    },
    isSet() {
      if (arguments.length < 1)
        throw new Error("Minimum 1 argument must be given");
      return this._callMethod(s, arguments);
    },
    keys() {
      return this._callMethod(a, arguments);
    },
  };
  if (typeof Cookies !== "undefined") {
    window.name || (window.name = Math.floor(1e8 * Math.random()));
    const m = {
      _cookie: !0,
      _prefix: "",
      _expires: null,
      _path: null,
      _domain: null,
      setItem(e, t) {
        Cookies.set(this._prefix + e, t, {
          expires: this._expires,
          path: this._path,
          domain: this._domain,
        });
      },
      getItem(e) {
        return Cookies.get(this._prefix + e);
      },
      removeItem(e) {
        return Cookies.remove(this._prefix + e, { path: this._path });
      },
      clear() {
        for (const e in Cookies.get())
          e != "" &&
            ((!this._prefix && e.indexOf(c) === -1 && e.indexOf(u) === -1) ||
              (this._prefix && e.indexOf(this._prefix) === 0)) &&
            Cookies.remove(e);
      },
      setExpires(e) {
        return (this._expires = e), this;
      },
      setPath(e) {
        return (this._path = e), this;
      },
      setDomain(e) {
        return (this._domain = e), this;
      },
      setConf(e) {
        return (
          e.path && (this._path = e.path),
          e.domain && (this._domain = e.domain),
          e.expires && (this._expires = e.expires),
          this
        );
      },
      setDefaultConf() {
        this._path = this._domain = this._expires = null;
      },
    };
    h ||
      ((window.localCookieStorage = e.extend({}, m, {
        _prefix: c,
        _expires: 3650,
      })),
      (window.sessionCookieStorage = e.extend({}, m, {
        _prefix: `${u + window.name}_`,
      }))),
      (window.cookieStorage = e.extend({}, m)),
      (e.cookieStorage = e.extend({}, g, {
        _type: "cookieStorage",
        setExpires(e) {
          return window.cookieStorage.setExpires(e), this;
        },
        setPath(e) {
          return window.cookieStorage.setPath(e), this;
        },
        setDomain(e) {
          return window.cookieStorage.setDomain(e), this;
        },
        setConf(e) {
          return window.cookieStorage.setConf(e), this;
        },
        setDefaultConf() {
          return window.cookieStorage.setDefaultConf(), this;
        },
      }));
  }
  (e.initNamespaceStorage = function(e) {
    return f(e);
  }),
    h
      ? ((e.localStorage = e.extend({}, g, { _type: "localStorage" })),
        (e.sessionStorage = e.extend({}, g, { _type: "sessionStorage" })))
      : ((e.localStorage = e.extend({}, g, { _type: "localCookieStorage" })),
        (e.sessionStorage = e.extend({}, g, {
          _type: "sessionCookieStorage",
        }))),
    (e.namespaceStorages = {}),
    (e.removeAllStorages = function(t) {
      e.localStorage.removeAll(t),
        e.sessionStorage.removeAll(t),
        e.cookieStorage && e.cookieStorage.removeAll(t),
        t || (e.namespaceStorages = {});
    }),
    (e.alwaysUseJsonInStorage = function(t) {
      (g.alwaysUseJson = t),
        (e.localStorage.alwaysUseJson = t),
        (e.sessionStorage.alwaysUseJson = t),
        e.cookieStorage && (e.cookieStorage.alwaysUseJson = t);
    });
});
