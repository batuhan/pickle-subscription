!(function(n, t) {
  typeof exports === "object" && typeof module !== "undefined"
    ? t(exports)
    : typeof define === "function" && define.amd
    ? define(["exports"], t)
    : t((n.topojson = n.topojson || {}));
})(this, function(n) {
  function t() {}
  function r(n) {
    if (!n) return t;
    let r;
    let e;
    const o = n.scale[0];
    const i = n.scale[1];
    const u = n.translate[0];
    const f = n.translate[1];
    return function(n, t) {
      t || (r = e = 0),
        (n[0] = (r += n[0]) * o + u),
        (n[1] = (e += n[1]) * i + f);
    };
  }
  function e(n) {
    if (!n) return t;
    let r;
    let e;
    const o = n.scale[0];
    const i = n.scale[1];
    const u = n.translate[0];
    const f = n.translate[1];
    return function(n, t) {
      t || (r = e = 0);
      const c = Math.round((n[0] - u) / o);
      const a = Math.round((n[1] - f) / i);
      (n[0] = c - r), (n[1] = a - e), (r = c), (e = a);
    };
  }
  function o(n, t) {
    for (var r, e = n.length, o = e - t; o < --e; )
      (r = n[o]), (n[o++] = n[e]), (n[e] = r);
  }
  function i(n, t) {
    for (var r = 0, e = n.length; r < e; ) {
      const o = (r + e) >>> 1;
      n[o] < t ? (r = o + 1) : (e = o);
    }
    return r;
  }
  function u(n, t) {
    return t.type === "GeometryCollection"
      ? {
          type: "FeatureCollection",
          features: t.geometries.map(function(t) {
            return f(n, t);
          }),
        }
      : f(n, t);
  }
  function f(n, t) {
    const r = {
      type: "Feature",
      id: t.id,
      properties: t.properties || {},
      geometry: c(n, t),
    };
    return t.id == null && delete r.id, r;
  }
  function c(n, t) {
    function e(n, t) {
      t.length && t.pop();
      for (var r, e = l[n < 0 ? ~n : n], i = 0, u = e.length; i < u; ++i)
        t.push((r = e[i].slice())), s(r, i);
      n < 0 && o(t, u);
    }
    function i(n) {
      return (n = n.slice()), s(n, 0), n;
    }
    function u(n) {
      for (var t = [], r = 0, o = n.length; r < o; ++r) e(n[r], t);
      return t.length < 2 && t.push(t[0].slice()), t;
    }
    function f(n) {
      for (var t = u(n); t.length < 4; ) t.push(t[0].slice());
      return t;
    }
    function c(n) {
      return n.map(f);
    }
    function a(n) {
      const t = n.type;
      return t === "GeometryCollection"
        ? { type: t, geometries: n.geometries.map(a) }
        : t in h
        ? { type: t, coordinates: h[t](n) }
        : null;
    }
    var s = r(n.transform);
    var l = n.arcs;
    var h = {
      Point(n) {
        return i(n.coordinates);
      },
      MultiPoint(n) {
        return n.coordinates.map(i);
      },
      LineString(n) {
        return u(n.arcs);
      },
      MultiLineString(n) {
        return n.arcs.map(u);
      },
      Polygon(n) {
        return c(n.arcs);
      },
      MultiPolygon(n) {
        return n.arcs.map(c);
      },
    };
    return a(t);
  }
  function a(n, t) {
    function r(t) {
      let r;
      const e = n.arcs[t < 0 ? ~t : t];
      const o = e[0];
      return (
        n.transform
          ? ((r = [0, 0]),
            e.forEach(function(n) {
              (r[0] += n[0]), (r[1] += n[1]);
            }))
          : (r = e[e.length - 1]),
        t < 0 ? [r, o] : [o, r]
      );
    }
    function e(n, t) {
      for (const r in n) {
        const e = n[r];
        delete t[e.start],
          delete e.start,
          delete e.end,
          e.forEach(function(n) {
            o[n < 0 ? ~n : n] = 1;
          }),
          f.push(e);
      }
    }
    var o = {};
    const i = {};
    const u = {};
    var f = [];
    let c = -1;
    return (
      t.forEach(function(r, e) {
        let o;
        const i = n.arcs[r < 0 ? ~r : r];
        i.length < 3 &&
          !i[1][0] &&
          !i[1][1] &&
          ((o = t[++c]), (t[c] = r), (t[e] = o));
      }),
      t.forEach(function(n) {
        let t;
        let e;
        const o = r(n);
        const f = o[0];
        const c = o[1];
        if ((t = u[f]))
          if ((delete u[t.end], t.push(n), (t.end = c), (e = i[c]))) {
            delete i[e.start];
            const a = e === t ? t : t.concat(e);
            i[(a.start = t.start)] = u[(a.end = e.end)] = a;
          } else i[t.start] = u[t.end] = t;
        else if ((t = i[c]))
          if ((delete i[t.start], t.unshift(n), (t.start = f), (e = u[f]))) {
            delete u[e.end];
            const s = e === t ? t : e.concat(t);
            i[(s.start = e.start)] = u[(s.end = t.end)] = s;
          } else i[t.start] = u[t.end] = t;
        else (t = [n]), (i[(t.start = f)] = u[(t.end = c)] = t);
      }),
      e(u, i),
      e(i, u),
      t.forEach(function(n) {
        o[n < 0 ? ~n : n] || f.push([n]);
      }),
      f
    );
  }
  function s(n) {
    return c(n, l.apply(this, arguments));
  }
  function l(n, t, r) {
    function e(n) {
      const t = n < 0 ? ~n : n;
      (s[t] || (s[t] = [])).push({ i: n, g: c });
    }
    function o(n) {
      n.forEach(e);
    }
    function i(n) {
      n.forEach(o);
    }
    function u(n) {
      n.type === "GeometryCollection"
        ? n.geometries.forEach(u)
        : n.type in l && ((c = n), l[n.type](n.arcs));
    }
    const f = [];
    if (arguments.length > 1) {
      var c;
      var s = [];
      var l = {
        LineString: o,
        MultiLineString: i,
        Polygon: i,
        MultiPolygon(n) {
          n.forEach(i);
        },
      };
      u(t),
        s.forEach(
          arguments.length < 3
            ? function(n) {
                f.push(n[0].i);
              }
            : function(n) {
                r(n[0].g, n[n.length - 1].g) && f.push(n[0].i);
              },
        );
    } else for (let h = 0, p = n.arcs.length; h < p; ++h) f.push(h);
    return { type: "MultiLineString", arcs: a(n, f) };
  }
  function h(n) {
    const t = n[0];
    const r = n[1];
    const e = n[2];
    return Math.abs(
      (t[0] - e[0]) * (r[1] - t[1]) - (t[0] - r[0]) * (e[1] - t[1]),
    );
  }
  function p(n) {
    for (var t, r = -1, e = n.length, o = n[e - 1], i = 0; ++r < e; )
      (t = o), (o = n[r]), (i += t[0] * o[1] - t[1] * o[0]);
    return i / 2;
  }
  function v(n) {
    return c(n, g.apply(this, arguments));
  }
  function g(n, t) {
    function r(n) {
      n.forEach(function(t) {
        t.forEach(function(t) {
          (o[(t = t < 0 ? ~t : t)] || (o[t] = [])).push(n);
        });
      }),
        i.push(n);
    }
    function e(t) {
      return Math.abs(p(c(n, { type: "Polygon", arcs: [t] }).coordinates[0]));
    }
    var o = {};
    var i = [];
    const u = [];
    return (
      t.forEach(function(n) {
        n.type === "Polygon"
          ? r(n.arcs)
          : n.type === "MultiPolygon" && n.arcs.forEach(r);
      }),
      i.forEach(function(n) {
        if (!n._) {
          const t = [];
          const r = [n];
          for (n._ = 1, u.push(t); (n = r.pop()); )
            t.push(n),
              n.forEach(function(n) {
                n.forEach(function(n) {
                  o[n < 0 ? ~n : n].forEach(function(n) {
                    n._ || ((n._ = 1), r.push(n));
                  });
                });
              });
        }
      }),
      i.forEach(function(n) {
        delete n._;
      }),
      {
        type: "MultiPolygon",
        arcs: u.map(function(t) {
          let r;
          let i = [];
          if (
            (t.forEach(function(n) {
              n.forEach(function(n) {
                n.forEach(function(n) {
                  o[n < 0 ? ~n : n].length < 2 && i.push(n);
                });
              });
            }),
            (i = a(n, i)),
            (r = i.length) > 1)
          )
            for (var u, f, c = 1, s = e(i[0]); c < r; ++c)
              (u = e(i[c])) > s &&
                ((f = i[0]), (i[0] = i[c]), (i[c] = f), (s = u));
          return i;
        }),
      }
    );
  }
  function d(n) {
    function t(n, t) {
      n.forEach(function(n) {
        n < 0 && (n = ~n);
        const r = o[n];
        r ? r.push(t) : (o[n] = [t]);
      });
    }
    function r(n, r) {
      n.forEach(function(n) {
        t(n, r);
      });
    }
    function e(n, t) {
      n.type === "GeometryCollection"
        ? n.geometries.forEach(function(n) {
            e(n, t);
          })
        : n.type in f && f[n.type](n.arcs, t);
    }
    var o = {};
    const u = n.map(function() {
      return [];
    });
    var f = {
      LineString: t,
      MultiLineString: r,
      Polygon: r,
      MultiPolygon(n, t) {
        n.forEach(function(n) {
          r(n, t);
        });
      },
    };
    n.forEach(e);
    for (let c in o)
      for (let a = o[c], s = a.length, l = 0; l < s; ++l)
        for (let h = l + 1; h < s; ++h) {
          var p;
          const v = a[l];
          const g = a[h];
          (p = u[v])[(c = i(p, g))] !== g && p.splice(c, 0, g),
            (p = u[g])[(c = i(p, v))] !== v && p.splice(c, 0, v);
        }
    return u;
  }
  function y(n, t) {
    return n[1][2] - t[1][2];
  }
  function m() {
    function n(n, t) {
      for (; t > 0; ) {
        const r = ((t + 1) >> 1) - 1;
        const o = e[r];
        if (y(n, o) >= 0) break;
        (e[(o._ = t)] = o), (e[(n._ = t = r)] = n);
      }
    }
    function t(n, t) {
      for (;;) {
        const r = (t + 1) << 1;
        const i = r - 1;
        let u = t;
        let f = e[u];
        if (
          (i < o && y(e[i], f) < 0 && (f = e[(u = i)]),
          r < o && y(e[r], f) < 0 && (f = e[(u = r)]),
          u === t)
        )
          break;
        (e[(f._ = t)] = f), (e[(n._ = t = u)] = n);
      }
    }
    const r = {};
    var e = [];
    var o = 0;
    return (
      (r.push = function(t) {
        return n((e[(t._ = o)] = t), o++), o;
      }),
      (r.pop = function() {
        if (!(o <= 0)) {
          let n;
          const r = e[0];
          return --o > 0 && ((n = e[o]), t((e[(n._ = 0)] = n), 0)), r;
        }
      }),
      (r.remove = function(r) {
        let i;
        const u = r._;
        if (e[u] === r)
          return (
            u !== --o &&
              ((i = e[o]), (y(i, r) < 0 ? n : t)((e[(i._ = u)] = i), u)),
            u
          );
      }),
      r
    );
  }
  function E(n, t) {
    function o(n) {
      f.remove(n), (n[1][2] = t(n)), f.push(n);
    }
    const i = r(n.transform);
    const u = e(n.transform);
    var f = m();
    return (
      t || (t = h),
      n.arcs.forEach(function(n) {
        let r;
        let e;
        let c;
        let a;
        const s = [];
        let l = 0;
        for (e = 0, c = n.length; e < c; ++e)
          (a = n[e]), i((n[e] = [a[0], a[1], 1 / 0]), e);
        for (e = 1, c = n.length - 1; e < c; ++e)
          (r = n.slice(e - 1, e + 2)), (r[1][2] = t(r)), s.push(r), f.push(r);
        for (e = 0, c = s.length; e < c; ++e)
          (r = s[e]), (r.previous = s[e - 1]), (r.next = s[e + 1]);
        for (; (r = f.pop()); ) {
          const h = r.previous;
          const p = r.next;
          r[1][2] < l ? (r[1][2] = l) : (l = r[1][2]),
            h && ((h.next = p), (h[2] = r[2]), o(h)),
            p && ((p.previous = h), (p[0] = r[0]), o(p));
        }
        n.forEach(u);
      }),
      n
    );
  }
  const M = "1.6.27";
  (n.version = M),
    (n.mesh = s),
    (n.meshArcs = l),
    (n.merge = v),
    (n.mergeArcs = g),
    (n.feature = u),
    (n.neighbors = d),
    (n.presimplify = E),
    Object.defineProperty(n, "__esModule", { value: !0 });
});
